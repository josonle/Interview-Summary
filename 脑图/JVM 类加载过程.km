{"root":{"data":{"id":"bszz9sna39s0","created":1553865283551,"text":"JVM 类加载过程"},"children":[{"data":{"id":"bszz9z8xfjk0","created":1553865297921,"text":"1.加载","expandState":"expand","hyperlink":"http://www.cnblogs.com/lanxuezaipiao/p/4138511.html","hyperlinkTitle":""},"children":[{"data":{"id":"bszzawritx40","created":1553865370879,"text":"JVM提供三种类加载器"},"children":[{"data":{"id":"bszzc7mv0c80","created":1553865472906,"text":"启动类加载器"},"children":[{"data":{"id":"bszzd9nhqoo0","created":1553865555662,"text":"加载JAVA_HOME/lib下的类","note":"> 或通过-Xbootclasspath参数指定路径中的，且被虚拟机认可（按文件名识别，如rt.jar）的类"},"children":[]},{"data":{"id":"bt029x50q0w0","created":1553873756661,"text":"不是java类，无需加载，嵌套在jvm内核里\njvm启动时，就启动"},"children":[]}]},{"data":{"id":"bszzcc5d3zs0","created":1553865482732,"text":"扩展类加载器"},"children":[{"data":{"id":"bszzcyy1yrs0","created":1553865532356,"text":"加载JAVA_HOME/lib/ext下的类","note":"> 或通过java.ext.dirs系统变量指定路径中的类库"},"children":[]}]},{"data":{"id":"bszzcex4qow0","created":1553865488765,"text":"应用程序类加载器"},"children":[{"data":{"id":"bszzcmgnir40","created":1553865505183,"text":"加载classpath用户路径上的类"},"children":[]}]}]},{"data":{"id":"bszzbdpaqjc0","created":1553865407750,"text":"如何进行类加载"},"children":[{"data":{"id":"bszzb3bu1f40","created":1553865385168,"text":"通过双亲委派模型进行类加载"},"children":[{"data":{"id":"bszzgbc3crk0","created":1553865794419,"text":"双亲委派机制","note":"当一个类加载器接到加载类的请求时，会优先交付给父类加载器去加载，依次迭代，*最终会交给最顶层的启动类加载器来加载任务*。但当父类加载器*无法加载*时，才会自己尝试加载任务\n\n![](https://upload-images.jianshu.io/upload_images/2184951-280bdfe9328e3188.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/339/format/webp)"},"children":[]},{"data":{"id":"bszzmvncoco0","created":1553866308820,"text":"优势"},"children":[]}]},{"data":{"id":"bszzbmgl2ao0","created":1553865426814,"text":"自定义类加载器（继承java.lang.ClassLoader）"},"children":[]}]},{"data":{"id":"bt23s6r7vlk0","created":1554081129172,"text":"加载做了什么？"},"children":[{"data":{"id":"bt23se5vuq00","created":1554081145297,"text":"通过类的全限定名获取类的二进制流"},"children":[]},{"data":{"id":"bt23syjlan40","created":1554081189661,"text":"把二进制流中的静态存储结构转化为方法运行时的数据结构"},"children":[]},{"data":{"id":"bt23tnoxuso0","created":1554081244404,"text":"在内存中生成该类的Class对象作为类的数据访问入口"},"children":[]}]}]},{"data":{"id":"bt1ixguq2740","created":1554022299665,"text":"链接","expandState":"expand"},"children":[{"data":{"id":"bszza2rpoow0","created":1553865305587,"text":"2.验证","note":"为了确保Class字节码文件满足JVM要求，所以要对其字节流数据进行验证"},"children":[{"data":{"id":"bszzr0ac06o0","created":1553866632374,"text":"格式验证"},"children":[{"data":{"id":"bszzsc2xfds0","created":1553866736411,"text":"验证字节流是否符合class文件格式的规范，并且能被当前虚拟机处理"},"children":[]}]},{"data":{"id":"bszzr7othhk0","created":1553866648487,"text":"元数据验证"},"children":[{"data":{"id":"bszzsk5as8w0","created":1553866753970,"text":"对字节码描述的数据进行语义分析，以保证符合Java语言规范"},"children":[]}]},{"data":{"id":"bszzr2snfcg0","created":1553866637835,"text":"字节码验证"},"children":[{"data":{"id":"bszzssuh68w0","created":1553866772906,"text":"对类的方法体进行分析，确保在方法运行时不会有危害虚拟机的事件发生"},"children":[]}]},{"data":{"id":"bszzrb3kgtc0","created":1553866655909,"text":"符号引用验证"},"children":[{"data":{"id":"bszzt0q74u80","created":1553866790061,"text":"为了确保后续的解析动作能够正常执行，对符号引用进行验证"},"children":[]}]}]},{"data":{"id":"bszza5h71y80","created":1553865311482,"text":"3.准备"},"children":[{"data":{"id":"bszzv8xmy5k0","created":1553866964654,"text":"为类变量（static修饰的静态变量）在方法区分配内存并附初值","note":"像`private static int a = 10；`，赋初值a=0，注意不是10（只有初始化阶段才会a=10）\n*但对于静态常量（static final修饰）而言不同*，`private static final int a = 10；`编译时会为a生成ConstantValue属性，ConstanValue属性会在准备阶段赋对应的值（此时a=10）"},"children":[]}]},{"data":{"id":"bszza915cqw0","created":1553865319218,"text":"4.解析"},"children":[{"data":{"id":"bszzz5u68mg0","created":1553867271370,"text":"将常量池的符号引用替换为直接引用"},"children":[]},{"data":{"id":"bszzzeinfnc0","created":1553867290265,"text":"符号引用和直接引用"},"children":[{"data":{"id":"bt00037cn200","created":1553867344001,"text":"符号引用使用一组符号来描述所引用的目标，可以是任何形式的字面常量，定义在Class文件格式中"},"children":[]},{"data":{"id":"bszzzwge3qo0","created":1553867329310,"text":"直接引用可以是直接指向目标的指针、相对偏移量或则能间接定位到目标的句柄"},"children":[]}]}]}]},{"data":{"id":"bszzad4tx0g0","created":1553865328148,"text":"5.初始化"},"children":[{"data":{"id":"bt01sbur0wg0","created":1553872378137,"text":"执行类构造器的clinit方法，对静态变量、静态块进行初始化"},"children":[{"data":{"id":"bt01ut45dfc0","created":1553872572439,"text":"并非实例构造器方法"},"children":[]}]},{"data":{"id":"bt01tjkn9fs0","created":1553872473304,"text":"由编译器完成"},"children":[]},{"data":{"id":"bt01tntfoy00","created":1553872482543,"text":"clinit方法对于类和接口不是必须的，如果没有静态变量、块，编译器就不会生成该方法"},"children":[]},{"data":{"id":"bt01v5y7ug80","created":1553872600378,"text":"无需显示调用父类的clinit方法，虚拟机会自动调用，\n保证父类的clinit优先执行"},"children":[]},{"data":{"id":"bt01w1alxco0","created":1553872668608,"text":"多线程环境下clinit方法是加了锁同步的"},"children":[{"data":{"id":"bt026w2vda00","created":1553873519262,"text":"但clinit只是执行一次，想想static静态块"},"children":[]}]},{"data":{"id":"bt01xqkxstc0","created":1553872802016,"text":"当父接口中定义变量时，才会预先执行父接口的clinit方法","note":"执行接口的<clinit>方法不需要先执行父接口的<clinit>，只有使用父接口中定义的变量时，才会执行"},"children":[]}]},{"data":{"id":"bszzafczkig0","created":1553865332995,"text":"6.使用"},"children":[]},{"data":{"id":"bszzaiqltg00","created":1553865340349,"text":"7.卸载"},"children":[]}]},"template":"default","theme":"fresh-blue","version":"1.4.43"}