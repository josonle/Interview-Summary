{"root":{"data":{"id":"bssdve6wu7c0","created":1553093991984,"text":"MySQL掌握","expandState":"expand"},"children":[{"data":{"id":"bssdvqonw0w0","created":1553094019178,"text":"MyISAM和InnoDB区别","hyperlink":"https://juejin.im/post/5b1685bef265da6e5c3c1c34#heading-4","hyperlinkTitle":"参考","expandState":"expand"},"children":[{"data":{"id":"bssdw4certs0","created":1553094048913,"text":"MyISAM特点","note":"MySQL5.5版本前的默认存储引擎，5.6引入了InnoDB\n\n并非InnoDB是最好的选择，有些情况下适合使用MyISAM\n> MyISAM更适合读密集的表，而InnoDB更适合写密集的的表。 在数据库做主从分离的情况下，经常选择MyISAM作为从库的存储引擎","expandState":"expand"},"children":[{"data":{"id":"bssdw8gais00","created":1553094057854,"text":"不支持事务","priority":1,"expandState":"expand"},"children":[]},{"data":{"id":"bssdwdi8br40","created":1553094068856,"text":"表锁，不支持行锁","note":"读取时对需要读到的所有表加锁，写入时则对表加排他锁\n\n读操作同时也支持向表中插入数据记录","priority":1,"expandState":"expand"},"children":[]},{"data":{"id":"bssdwqt2w6o0","created":1553094097810,"text":"不支持外键","expandState":"expand"},"children":[]},{"data":{"id":"bssdxyycouo0","created":1553094193907,"text":"支持fulltext索引","expandState":"expand"},"children":[]},{"data":{"id":"bssdy7f5w9s0","created":1553094212338,"text":"对索引延迟更新，提升写的性能","expandState":"expand"},"children":[]},{"data":{"id":"bssdysp7bbc0","created":1553094258657,"text":"对不会修改的表支持压缩表，减少磁盘空间占用","priority":2,"expandState":"expand"},"children":[]},{"data":{"id":"bsse2o9qfq80","created":1553094562471,"text":"不支持崩溃后安全恢复","priority":2,"expandState":"expand"},"children":[]}]},{"data":{"id":"bsse15977zk0","created":1553094442716,"text":"InnoDB特点","expandState":"expand"},"children":[{"data":{"id":"bsse1nk8m000","created":1553094482566,"text":"支持事务","expandState":"expand"},"children":[]},{"data":{"id":"bsse1slshmg0","created":1553094493543,"text":"支持外键","expandState":"expand"},"children":[]},{"data":{"id":"bsse1vv1dow0","created":1553094500633,"text":"默认支持行锁","note":"并发性能更好（采用MVCC来支持高并发），但可能会造成死锁","expandState":"expand"},"children":[]},{"data":{"id":"bsse27zit200","created":1553094527025,"text":"支持崩溃后的安全恢复","expandState":"expand"},"children":[]},{"data":{"id":"bsse3nl8ogw0","created":1553094639354,"text":"5.6版本后InnoDB也支持fulltext索引","expandState":"expand"},"children":[]}]},{"data":{"id":"bsse59hlitc0","created":1553094765388,"text":"其他对比","expandState":"expand"},"children":[{"data":{"id":"bsse5chv8800","created":1553094771934,"text":"MyISAM会缓存表的行数及其他表的元数据信息metadata","expandState":"expand"},"children":[]}]}]},{"data":{"id":"bsssh99wle00","created":1553135200831,"text":"行锁、表锁和页锁","note":"锁，一种协调多进程或多线程并发访问资源的一种机制\n\nMyISAM中是不会产生死锁的，因为MyISAM总是一次性获得所需的全部锁，要么全部满足，要么全部等待。而在InnoDB中，锁是逐步获得的，就造成了死锁的可能。","expandState":"expand"},"children":[{"data":{"id":"bsssk45qwmg0","created":1553135424788,"text":"表锁（table-level locking","expandState":"expand","note":"> MyISAM、InnoDB、MEMORY支持\n\nMyISAM和MEMORY默认采用表级锁"},"children":[{"data":{"id":"bsssk8k4cgg0","created":1553135434364,"text":"每次操作锁住整张表","expandState":"expand"},"children":[{"data":{"id":"bt9493rpi6g0","created":1554793374559,"text":"也分表共享读锁（共享锁）、表独占写锁（排他锁）"},"children":[]}]},{"data":{"id":"bssske2hah40","created":1553135446359,"text":"开销小、加锁快","expandState":"expand"},"children":[]},{"data":{"id":"bssskgdz9m80","created":1553135451407,"text":"无死锁","expandState":"expand"},"children":[]},{"data":{"id":"bssskwffna80","created":1553135486324,"text":"锁定粒度大，发生锁冲突的概率最高，并发度最低","expandState":"expand"},"children":[]}]},{"data":{"id":"bsssk6a44k00","created":1553135429406,"text":"行锁（row-level locking","expandState":"collapse","note":"> InnoDB支持\n\nInnoDB支持行锁、表锁，但默认行锁"},"children":[{"data":{"id":"bssslfoukso0","created":1553135528252,"text":"每次操作锁住一行记录","expandState":"expand"},"children":[{"data":{"id":"bt947z729i80","created":1554793286240,"text":"行锁又分共享锁、排它锁"},"children":[]}]},{"data":{"id":"bsssll43afk0","created":1553135540058,"text":"开销大、加锁慢","expandState":"expand"},"children":[]},{"data":{"id":"bssslpnc3v40","created":1553135549928,"text":"会发生死锁","expandState":"expand"},"children":[]},{"data":{"id":"bssslwubl2w0","created":1553135565588,"text":"锁定粒度最小，发生锁冲突的概率最低，并发度也最高","expandState":"expand"},"children":[]},{"data":{"id":"bt94h632mtk0","created":1554794006513,"text":"Tip：InnoDB行锁的特性"},"children":[{"data":{"id":"bt94tp36aow0","created":1554794988248,"text":"InnoDB提供了三种行锁","hyperlink":"https://www.cnblogs.com/zhoujinyi/p/3435982.html","hyperlinkTitle":""},"children":[]},{"data":{"id":"bt94w5v25a00","created":1554795181491,"text":"InnoDB行锁是给索引项字段加锁实现的","priority":1,"expandState":"expand"},"children":[{"data":{"id":"bt94wtnb54g0","created":1554795233265,"text":"所以只有通过索引字段检索数据才会加上行锁","priority":2},"children":[]},{"data":{"id":"bt94xj6jrr40","created":1554795288848,"text":"注意这个特点，避免产生大量锁冲突影响并发性能"},"children":[]},{"data":{"id":"bt951n44ai80","created":1554795610865,"text":"表有多个索引的时候,不同的事务可以使用不同的索引锁定不同的行"},"children":[]}]},{"data":{"id":"bt953umuna80","created":1554795783964,"text":"行锁锁住索引，而索引又分主键索引，非主键索引","expandState":"expand","note":"在UPDATE、DELETE操作时，MySQL不仅锁定WHERE条件扫描过的所有索引记录，而且会锁定相邻的键值，即所谓的next-key locking"},"children":[{"data":{"id":"bt954l5n8gg0","created":1554795841696,"text":"sql使用了主键索引的话，会先锁住主键索引","layout_right_offset":{"x":-1,"y":13}},"children":[]},{"data":{"id":"bt9555jjuig0","created":1554795886073,"text":"sql使用了非主键索引，会先锁定该非主键索引，再锁定相关的主键索引","layout_right_offset":{"x":2,"y":18}},"children":[]},{"data":{"id":"bt956xnxnww0","created":1554796025652,"text":"死锁","layout_right_offset":{"x":-3,"y":23}},"children":[{"data":{"id":"bt9577ft4rc0","created":1554796046928,"text":"当两个事务同时执行，一个锁住了主键索引，在等待其他相关索引。\n另一个锁定了非主键索引，在等待主键索引。会发生死锁"},"children":[]},{"data":{"id":"bt957qziq740","created":1554796089479,"text":"发生死锁后，InnoDB一般都可以检测到，并使一个事务释放锁回退，另一个获取锁完成事务。"},"children":[]}]}]}]}]},{"data":{"id":"bt94aly04s00","created":1554793492486,"text":"页锁（page-level locking","note":"> BDB引擎支持\n\nBDB支持表锁，但默认页锁"},"children":[{"data":{"id":"bt94cylsccg0","created":1554793676774,"text":"每次锁定相邻的一组记录"},"children":[]},{"data":{"id":"bt94bhd3gxc0","created":1554793560879,"text":"锁定粒度介于行锁和表锁间，并发度一般"},"children":[]},{"data":{"id":"bt94c8n0y7k0","created":1554793620252,"text":"开销和加锁时间界于表锁和行锁之间"},"children":[]},{"data":{"id":"bt94c9pp7so0","created":1554793622591,"text":"会发生死锁"},"children":[]}]}]},{"data":{"id":"bsssn78rz0o0","created":1553135666594,"text":"索引分类","hyperlink":"http://benjaminwhx.com/2018/02/26/MySQL%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8A%E6%85%A2%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/#1%E3%80%81%E7%B4%A2%E5%BC%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BB%A5%E5%8F%8A%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80","hyperlinkTitle":"MySQL索引原理以及慢查询优化","note":"用于优化查询，适合where、join中的条件","expandState":"collapse"},"children":[{"data":{"id":"bsssnbo5dk00","created":1553135676231,"text":"聚集索引和非聚集索引","image":"https://img-blog.csdn.net/20160127144445485","imageTitle":"","imageSize":{"width":200,"height":104},"hyperlink":"https://www.cnblogs.com/aspnethot/articles/1504082.html","hyperlinkTitle":"","expandState":"expand"},"children":[{"data":{"id":"bsstfufq5280","created":1553137911277,"text":"聚集索引","note":"数据**按照索引的顺序进行组织和排列**，这种就是聚集索引\n> 简单点说就是数据会按照索引的顺序存储\n\n其他一般的索引就是非聚集索引","expandState":"expand"},"children":[{"data":{"id":"bsstiqvwp800","created":1553138138641,"text":"InnoDB中默认主键索引就是聚集索引（不是绝对）","expandState":"expand"},"children":[{"data":{"id":"bst3d61p6s00","created":1553165912557,"text":"默认按照主键为聚集索引","expandState":"expand"},"children":[]},{"data":{"id":"bst3dier66g0","created":1553165939468,"text":"  如果没有定义主键，尝试选择唯一的非空索引代替为聚集索引","expandState":"expand"},"children":[]},{"data":{"id":"bst3ea1ahw80","created":1553165999604,"text":"以上都没有的话，InnoDB会默认定义隐藏的主键为聚集索引","expandState":"expand","note":"> 数据库引擎 将向表自动添加一个四字节 uniqueifier 列。\n必要时，数据库引擎 将向行自动添加一个 uniqueifier 值，使每个键唯一。此列和列值供内部使用，用户不能查看或访问"},"children":[]}]},{"data":{"id":"bst70oimxs00","created":1553176218469,"text":"聚集索引不一定是唯一索引"},"children":[{"data":{"id":"bst72k6zojs0","created":1553176365786,"text":"???待测试","priority":1},"children":[]},{"data":{"id":"bt0fkgdq7xs0","created":1553911256617,"text":"mysql中是唯一的，从上面定义可知。可能其他数据库不是唯一吧"},"children":[]}]},{"data":{"id":"bsstokltqy00","created":1553138595156,"text":"索引的叶子节点是存放数据","expandState":"expand","priority":1},"children":[{"data":{"id":"bt0fkxvamow0","created":1553911294684,"text":"主键索引叶子节点存放的是行数据"},"children":[{"data":{"id":"bt0flr2rlxc0","created":1553911358263,"text":"行数据：主键所对应的数据"},"children":[]}]},{"data":{"id":"bt0fl6cc83k0","created":1553911313129,"text":"非主键索引叶子节点存放的是主键","layout_right_offset":{"x":100,"y":10}},"children":[{"data":{"id":"bt0fleisnhs0","created":1553911330934,"text":"涉及回表"},"children":[]}]}]},{"data":{"id":"bsstq9wwybk0","created":1553138728610,"text":"聚集索引一个表只能有一个，而非聚集索引一个表可以存在多个","expandState":"expand","priority":null},"children":[]},{"data":{"id":"bsstqm2rons0","created":1553138755085,"text":"聚集索引存储记录是物理上连续存在，而非聚集索引是逻辑上的连续，物理存储并不连续","expandState":"expand"},"children":[]},{"data":{"id":"bst3apxuooo0","created":1553165720767,"text":"聚集索引查询速度快，写入操作比较费时","expandState":"expand"},"children":[]}]},{"data":{"id":"bsstfx9whls0","created":1553137917455,"text":"非聚集索引","expandState":"expand"},"children":[{"data":{"id":"bsstizmnaww0","created":1553138157672,"text":"MyISAM只有非聚集索引","expandState":"expand"},"children":[]},{"data":{"id":"bsstovhznsg0","created":1553138618868,"text":"叶子节点任然是索引节点，不过会有指针指向数据块","expandState":"expand"},"children":[]}]}]},{"data":{"id":"bst3sskwvhc0","created":1553167137070,"text":"hash索引","expandState":"expand"},"children":[]},{"data":{"id":"bst3szg51lc0","created":1553167152019,"text":"fulltext索引","expandState":"expand"},"children":[]},{"data":{"id":"bst3t2y6t9k0","created":1553167159642,"text":"主键索引","expandState":"expand"},"children":[{"data":{"id":"bst6yg9paa00","created":1553176043786,"text":"主键只有一个，但唯一索引可以有多个"},"children":[]},{"data":{"id":"bst6yqktis80","created":1553176066226,"text":"主键索引不为null，唯一索引可以插入null"},"children":[]}]},{"data":{"id":"bst3t6pfyfs0","created":1553167167819,"text":"唯一索引","expandState":"expand"},"children":[]},{"data":{"id":"bst3t8rh0s80","created":1553167172296,"text":"普通索引、组合索引","expandState":"expand"},"children":[]},{"data":{"id":"bst1bbp1q1k0","created":1553160125904,"text":"索引使用和优化","hyperlink":"https://juejin.im/post/5b68e3636fb9a04fd343ba99#heading-4","hyperlinkTitle":"深入浅出MySQL","expandState":"expand"},"children":[{"data":{"id":"bst3z762kog0","created":1553167639010,"text":"索引适合where和on子句中的列","expandState":"expand"},"children":[{"data":{"id":"bt0fmsyw2200","created":1553911440746,"text":"还有order by，group by"},"children":[]}]},{"data":{"id":"bst3gn5mfps0","created":1553166184892,"text":"组合索引默认遵守最左匹配原则","expandState":"expand"},"children":[]},{"data":{"id":"bst3h2di7yg0","created":1553166218020,"text":"对于like \"%text%\"这种%在开头的不会使用索引，text%会","expandState":"expand"},"children":[]},{"data":{"id":"bst3hxvnhug0","created":1553166286598,"text":"索引用于=、in这类比较的精确匹配","expandState":"expand"},"children":[]},{"data":{"id":"bst438cjmgg0","created":1553167955035,"text":"union、or也可以命中索引","expandState":"expand"},"children":[{"data":{"id":"bst43lir7uw0","created":1553167983708,"text":"查询的CPU消耗：or > in >union","expandState":"expand"},"children":[]},{"data":{"id":"bst4409on000","created":1553168015811,"text":"用or分割开的条件，or前条件有索引，or后的列没有索引，那么涉及的索引不会被用到","expandState":"expand"},"children":[]}]},{"data":{"id":"bst44ly68a00","created":1553168063005,"text":"负向条件查询不能使用索引，可以优化为 in 查询","note":"> !=、<>、not in、not exists、not like都是负向条件\n\n对于数据较为均匀的场景是会失效","expandState":"expand"},"children":[{"data":{"id":"bst46q43wu00","created":1553168228799,"text":"不一定的，以数据量定，mysql会自动判断","hyperlink":"https://segmentfault.com/q/1010000009426506/a-1020000009432008","hyperlinkTitle":"","expandState":"expand"},"children":[]}]},{"data":{"id":"bst3i9x5b480","created":1553166312810,"text":"索引也可用与范围查询","expandState":"expand"},"children":[{"data":{"id":"bst3ifkcyco0","created":1553166325097,"text":"但对字段进行范围查询>、=、<、between and等，其后的列就不能使用索引","expandState":"expand"},"children":[]},{"data":{"id":"bst48uhtc480","created":1553168395063,"text":"范围查询和等值查询同时存在，优先匹配等值查询列的索引","expandState":"expand"},"children":[]}]},{"data":{"id":"bst3ju868io0","created":1553166435376,"text":"(比如说where中) 对索引字段用了函数或表达式不会使用索引","expandState":"expand"},"children":[]},{"data":{"id":"bst4gha23sg0","created":1553168993209,"text":"is null可以命中索引，is not null反而不能","expandState":"expand"},"children":[]},{"data":{"id":"bst3kuu812w0","created":1553166515074,"text":"选择哪些字段建立索引","expandState":"expand"},"children":[{"data":{"id":"bst3l46oktc0","created":1553166535418,"text":"适合字段分布均匀的，像性别就不适合","expandState":"expand"},"children":[]},{"data":{"id":"bst4fd0ah1c0","created":1553168905547,"text":"选择的索引列不允许为null，或者组合索引不允许字段全为null","expandState":"expand"},"children":[]},{"data":{"id":"bst4gz7qjs00","created":1553169032251,"text":"不适合选经常更新的字段作为索引","expandState":"expand"},"children":[]},{"data":{"id":"bst4h9i3wqw0","created":1553169054646,"text":"多表联合时on条件上最好设置索引，where也是同样","expandState":"expand"},"children":[]}]},{"data":{"id":"bst3ms6ypv40","created":1553166666042,"text":"优化","expandState":"expand"},"children":[{"data":{"id":"bst1bhzskfs0","created":1553160139615,"text":"索引选择要适当，过多和选择不当，反而会导致低效","note":"索引过多，一来可能产生索引碎片，二来每次对记录更新都要修改索引会增加成本，三是会增加查询优化和选择的时间","expandState":"expand"},"children":[]},{"data":{"id":"bst3mxrcelc0","created":1553166678158,"text":"可以考虑选择前缀索引","note":"即以字段前部分字符为索引，索引变短，可以减少索引文件大小、维护开销，提高索引效率\n```\n//选择col的前n个字符为索引\nalter table Table_Name add index (col(n));\n```","expandState":"expand"},"children":[]},{"data":{"id":"bst49cwy4xs0","created":1553168435160,"text":"使用覆盖索引进行查询，避免回表","expandState":"expand"},"children":[]}]}]}]},{"data":{"id":"bst4bfg3fyw0","created":1553168597400,"text":"覆盖索引与回表","expandState":"collapse"},"children":[{"data":{"id":"bt0fppva3vk0","created":1553911669090,"text":"回表"},"children":[{"data":{"id":"bt0fpstuqlk0","created":1553911675534,"text":"主键索引叶子节点存的是整行数据，而\n非主键索引叶子节点存的是主键"},"children":[]},{"data":{"id":"bt0fqb6zg680","created":1553911715510,"text":"所以对于非主键索引而言，先查询到对应主键，再到主键索引中搜索"},"children":[{"data":{"id":"bt0fr0yi55s0","created":1553911771594,"text":"回到主键索引中搜索的过程就叫 回表","font-weight":"bold","color":"#c00000"},"children":[]}]}]},{"data":{"id":"bt0fru3vvrk0","created":1553911835046,"text":"覆盖索引"},"children":[{"data":{"id":"bt0fry9obdc0","created":1553911844103,"text":"查询列包含索引字段"},"children":[{"data":{"id":"bt0ft2wg8yo0","created":1553911932551,"text":"避免了回表问题，显著提高查询性能"},"children":[]}]}]}]},{"data":{"id":"bst4ck3ikww0","created":1553168685887,"text":"SQL注意项（待补充）","expandState":"expand"},"children":[{"data":{"id":"bst4cv2ql4g0","created":1553168709785,"text":"每次写sql查询时，通过explain命令看看有什么可以优化的地方","note":"![](https://user-gold-cdn.xitu.io/2018/8/5/1650a598885eeacb?imageslim)","hyperlink":null,"hyperlinkTitle":null,"image":"https://user-gold-cdn.xitu.io/2018/8/5/1650a598885eeacb?imageslim","imageTitle":"","imageSize":{"width":200,"height":24},"expandState":"expand"},"children":[]}]},{"data":{"id":"bthpnwubyww0","created":1555666257904,"text":"ACID事务如何实现？","expandState":"expand"},"children":[{"data":{"id":"bthpo0m24xk0","created":1555666266111,"text":"原子性"},"children":[{"data":{"id":"bthpt63b5a80","created":1555666669859,"text":"事务操作要么都成功，要么都失败回滚"},"children":[]},{"data":{"id":"bthq6gnwuv40","created":1555667711607,"text":"通过undo log机制实现"},"children":[]}]},{"data":{"id":"bthpo29u6ig0","created":1555666269726,"text":"一致性","note":"ACID中的一致性(C)：\n> - 在事务的执行的前后以及过程中不会违背对数据完整性的约束,所有对数据库写入的操作都应该是合法的,并不能产生不合法的数据状态\n- 应用层面上，指代码中正确的事务逻辑\n\n比如说，表中某个字段是唯一的，那么事务操作过程中/前后不能存在不唯一的情况。而逻辑正确，好比转账我扣了钱你就要增加相应的钱，不能我钱少了你没多\n\nCAP中的数据一致性(C)：\n> 分布式系统中的各个节点中对于同一数据的拷贝有着相同的值\n\n两者是不一样的"},"children":[{"data":{"id":"bthpqmefm3c0","created":1555666470268,"text":"原子性、持久性、隔离性都是为了保证一致性"},"children":[]}]},{"data":{"id":"bthpo3femjs0","created":1555666272239,"text":"持久性","hyperlink":"https://www.qiancheng.me/post/coding/mysql-001","hyperlinkTitle":"MYSQL解密：INNODB存储引擎重做日志漫游"},"children":[{"data":{"id":"bthptlcf8ls0","created":1555666703062,"text":"对数据库的写入是持久存储的、非易失的"},"children":[]},{"data":{"id":"bthq6o6o6aw0","created":1555667727978,"text":"通过redo log机制实现"},"children":[]}]},{"data":{"id":"bthpo4p0wiw0","created":1555666274998,"text":"隔离性"},"children":[{"data":{"id":"bthpuzf2ks00","created":1555666812061,"text":"事务执行不相互依赖"},"children":[{"data":{"id":"bthpvkl276g0","created":1555666858136,"text":"影响并发执行事务的性能"},"children":[]}]},{"data":{"id":"bthpv77s3080","created":1555666829034,"text":"四种隔离级别","note":"就是为了解决脏读、不可重复读、幻读的影响\n\n> 有一个表很好记的"},"children":[{"data":{"id":"bthpy8ofshc0","created":1555667067312,"text":"READ UNCOMMITED","note":"读未提交"},"children":[]},{"data":{"id":"bthpyfdzxi80","created":1555667081917,"text":"READ COMMITED","note":"读已提交"},"children":[]},{"data":{"id":"bthpyjfo91s0","created":1555667090725,"text":"REPETABLE READ","note":"可重复读"},"children":[]},{"data":{"id":"bthpyooo7jc0","created":1555667102154,"text":"SERIALIZABLE","note":"串行化"},"children":[]}]},{"data":{"id":"bthpxh856qg0","created":1555667007552,"text":"并发事务读取数据的可能"},"children":[{"data":{"id":"bthpxqmiqlc0","created":1555667028013,"text":"脏读","note":"事务访问了另一个事务未提交的数据"},"children":[]},{"data":{"id":"bthpxz8kqpk0","created":1555667046761,"text":"不可重复读","note":"事务前后访问某条数据，但在这之间有其他事务也访问了该数据并提交"},"children":[]},{"data":{"id":"bthpy2ar8480","created":1555667053423,"text":"幻读","note":"事务前后访问某表，但在这之间有其他事务也访问了该表并对表中数据进行了修改（增删等）\n\n不同于不可重复读的就是幻读是对表修改了"},"children":[]}]},{"data":{"id":"bthq6zdzxlk0","created":1555667752366,"text":"通过事务的并发控制实现"},"children":[{"data":{"id":"bthq75dv3ig0","created":1555667765419,"text":"锁机制（共享/互斥锁）"},"children":[]},{"data":{"id":"bthq7bfsh9s0","created":1555667778596,"text":"时间戳（类似乐观锁中版本号机制）"},"children":[]},{"data":{"id":"bthq7lw5rbc0","created":1555667801353,"text":"多版本并发控制（MVCC）"},"children":[]}]}]}]}]},"template":"right","theme":"fresh-blue-compat","version":"1.4.43"}