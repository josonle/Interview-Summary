{"root":{"data":{"id":"bt1grbrba5k0","created":1554016176170,"text":"JVM 垃圾回收机制","hyperlink":"https://segmentfault.com/a/1190000016187449#articleHeader11","hyperlinkTitle":""},"children":[{"data":{"id":"bt1grp0l7g80","created":1554016205029,"text":"如何判断对象可回收？","layout_mind_offset":{"x":-21,"y":27},"expandState":"collapse"},"children":[{"data":{"id":"bt1gru8ce3k0","created":1554016216382,"text":"引用计数法"},"children":[{"data":{"id":"bt1gs6y90mw0","created":1554016244070,"text":"引用计数器"},"children":[]},{"data":{"id":"bt1gsao1nv40","created":1554016252160,"text":"存在对象相互引用问题"},"children":[]}]},{"data":{"id":"bt1gs2bdf5k0","created":1554016233979,"text":"可达性分析"},"children":[{"data":{"id":"bt1gtjl73zs0","created":1554016349943,"text":"把一系列称为GC Roots的对象作为起点，向下搜索，\n搜索所走过的路径称作引用链。当一个对象\n到GC Roots没有任何引用链，则对象不可达，可回收"},"children":[]},{"data":{"id":"bt1gwvlvkgg0","created":1554016611198,"text":"可达性分析分析出不可达的对象不是立刻被回收的\n，至少要经历两次标记过程","note":"> 可达性分析法中不可达的对象被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 finalize 方法。当对象没有覆盖 finalize 方法，或 finalize 方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行。\n\n> 被判定为需要执行的对象将会被放在一个队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关联，否则就会被真的回收。"},"children":[]},{"data":{"id":"bt1gzjzijxc0","created":1554016820994,"text":"可作为GC Roots的对象"},"children":[{"data":{"id":"bt1gzrwve200","created":1554016838248,"text":"方法区"},"children":[{"data":{"id":"bt1gzx9z5wo0","created":1554016849924,"text":"常量引用的对象"},"children":[]},{"data":{"id":"bt1h02lmf800","created":1554016861512,"text":"类静态属性引用的对象"},"children":[]}]},{"data":{"id":"bt1h0ddvrgw0","created":1554016884989,"text":"虚拟机栈(本地变量表)中引用的对象"},"children":[]},{"data":{"id":"bt1gzpmtir40","created":1554016833287,"text":"本地方法栈JNI(Native方法)中引用的对象"},"children":[]}]}]}]},{"data":{"id":"bt1h1chnroo0","created":1554016961405,"text":"垃圾回收算法","expandState":"collapse"},"children":[{"data":{"id":"bt1h29tvpxs0","created":1554017033978,"text":"回收策略"},"children":[{"data":{"id":"bt1h2cftcwo0","created":1554017039657,"text":"分代收集"},"children":[{"data":{"id":"bt1hfw3lajk0","created":1554018101188,"text":"根据各个年代的特点选择合适的垃圾收集算法"},"children":[]}]},{"data":{"id":"bt1h2l4tey00","created":1554017058583,"text":"分区收集"},"children":[{"data":{"id":"bt1hg933gso0","created":1554018129456,"text":"将整个堆空间划分为连续的不同小区间, 每个小区间独立使用, 独立回收"},"children":[]},{"data":{"id":"bt1hh0f3t2w0","created":1554018188956,"text":"优点"},"children":[{"data":{"id":"bt1hh2qnnw00","created":1554018194008,"text":"可以控制一次对多少个区间进行回收"},"children":[{"data":{"id":"bt1hhp7ckuo0","created":1554018242906,"text":"而非整个堆，可以减少一次GC停顿的次数，所花的时间","note":"> 堆空间越大, 一次GC耗时就越长, 从而产生的停顿也越长"},"children":[]}]}]}]}]},{"data":{"id":"bt1h2pydlbs0","created":1554017069078,"text":"标记-清除法"},"children":[{"data":{"id":"bt1h3t65muo0","created":1554017154443,"text":"适合老年代"},"children":[]},{"data":{"id":"bt1h46dy82g0","created":1554017183212,"text":"先通过可达性分析标记需要清除的对象"},"children":[]},{"data":{"id":"bt1h4gic0f40","created":1554017205245,"text":"标记完后再清除所有被标记的对象"},"children":[]},{"data":{"id":"bt1h4wzvdk80","created":1554017241134,"text":"问题"},"children":[{"data":{"id":"bt1h4yn5bxc0","created":1554017244718,"text":"内存空间碎片问题","note":"清除被标记的对象可能会造成大量非连续的内存空间碎片，可能导致为较大对象分配内存时空间不足提前触发又一次回收"},"children":[]},{"data":{"id":"bt1h5534t9k0","created":1554017258746,"text":"效率问题","note":"标记和回收清除的效率都很低"},"children":[]}]}]},{"data":{"id":"bt1h2wovxag0","created":1554017083742,"text":"标记-整理法"},"children":[{"data":{"id":"bt1hcao8a8w0","created":1554017819454,"text":"适合老年代"},"children":[]},{"data":{"id":"bt1hce3aj6o0","created":1554017826895,"text":"标记过程同标记-清理法，但清除时会先把所有存活对象向一端移动，再清除端边界以外的内存"},"children":[]}]},{"data":{"id":"bt1h3izow7c0","created":1554017132284,"text":"复制算法"},"children":[{"data":{"id":"bt1h3lazo1c0","created":1554017137321,"text":"适合新生代"},"children":[]},{"data":{"id":"bt1h7mbnxls0","created":1554017452995,"text":"将内存空间划分成容量相等的两块，每次使用其中的一块"},"children":[]},{"data":{"id":"bt1h8cqrw4w0","created":1554017510505,"text":"当回收时，把非垃圾对象复制到另一块上去，再清空当前内存空间"},"children":[]},{"data":{"id":"bt1ha2d0t8w0","created":1554017644634,"text":"问题"},"children":[{"data":{"id":"bt1ha4jr9rc0","created":1554017649395,"text":"内存空间使用不足，浪费了一半"},"children":[]},{"data":{"id":"bt1hadu2s480","created":1554017669610,"text":"但没有碎片问题，简单"},"children":[]}]}]}]},{"data":{"id":"bt1hjggu0iw0","created":1554018380617,"text":"垃圾回收器","expandState":"collapse","hyperlink":"https://juejin.im/post/5c9f7d26f265da308a28923d","hyperlinkTitle":""},"children":[{"data":{"id":"bt1hjr1a9nc0","created":1554018403621,"text":"Serial回收器"},"children":[{"data":{"id":"bt1hkmwxweg0","created":1554018473016,"text":"Hotspot运行在Client模式下的默认新生代收集器"},"children":[]},{"data":{"id":"bt1hkoyxotk0","created":1554018477490,"text":"单线程的回收器","expandState":"expand"},"children":[{"data":{"id":"bt1hkurwcy00","created":1554018490125,"text":"垃圾回收时，会暂停其他工作线程，直到回收结束"},"children":[]}]},{"data":{"id":"bt1hm7h2xzk0","created":1554018596133,"text":"新生代采用复制算法，老年代采用标记-整理算法"},"children":[]},{"data":{"id":"bt1hlvfzju00","created":1554018569946,"text":"简单高效，适合jvm管理内存不大的情况"},"children":[]}]},{"data":{"id":"bt1hmbtw9a80","created":1554018605615,"text":"ParNew回收器"},"children":[{"data":{"id":"bt1hn3gz1ko0","created":1554018665784,"text":"Serial的多线程版本","note":"除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和Serial收集器完全一样"},"children":[{"data":{"id":"bt1ho7i94h40","created":1554018752932,"text":"运行在Server模式下的虚拟机的首要选择"},"children":[]}]},{"data":{"id":"bt1hm7h2xzk0","created":1554018596133,"text":"新生代采用复制算法，老年代采用标记-整理算法"},"children":[]}]},{"data":{"id":"bt1hp6vbzbc0","created":1554018829911,"text":"CMS回收器"},"children":[]},{"data":{"id":"bt1hpdtyryg0","created":1554018845066,"text":"G1回收器"},"children":[]}]},{"data":{"id":"bt1hrjfcvso0","created":1554019013971,"text":"JVM 堆内存分配","expandState":"collapse"},"children":[{"data":{"id":"bt1hrry8uqg0","created":1554019032528,"text":"新生代"},"children":[{"data":{"id":"bt1ht9cgitk0","created":1554019148757,"text":"Eden区+Survivor1区+Survivor2区"},"children":[]}]},{"data":{"id":"bt1hrtzc7gw0","created":1554019036947,"text":"老年代"},"children":[]},{"data":{"id":"bt1hrvxtqq00","created":1554019041209,"text":"永久代"},"children":[{"data":{"id":"bt1hrzgty1s0","created":1554019048889,"text":"jdk 1.8之后改为Metaspace(元空间)"},"children":[]},{"data":{"id":"bt1hsjtz0jk0","created":1554019093219,"text":"永久代使用jvm的堆空间"},"children":[]},{"data":{"id":"bt1hsr5igdc0","created":1554019109154,"text":"Metaspace直接使用物理内存空间"},"children":[]}]},{"data":{"id":"bt1htxhdj800","created":1554019201297,"text":"内存分配策略","expandState":"collapse"},"children":[{"data":{"id":"bt1hu93mzk00","created":1554019226587,"text":"对象优先在eden区分配"},"children":[]},{"data":{"id":"bt1hug6bjhs0","created":1554019241987,"text":"大对象直接进入老年代"},"children":[{"data":{"id":"bt1hx2j6dmw0","created":1554019447382,"text":"大对象：需要大量连续内存空间的对象，比如数组、字符串"},"children":[]},{"data":{"id":"bt1i5su6twg0","created":1554020131557,"text":"why？"},"children":[{"data":{"id":"bt1i60gmh2w0","created":1554020148151,"text":"新生代使用复制算法进行垃圾回收","expandState":"expand"},"children":[{"data":{"id":"bt1i5wzmjs80","created":1554020140593,"text":"避免在Eden区及两个Survivor区之间发生大量的内存复制"},"children":[]}]}]}]},{"data":{"id":"bt1hy0ttx400","created":1554019522037,"text":"长期存活的对象将进入老年代"},"children":[{"data":{"id":"bt1hyk7eab40","created":1554019564216,"text":"如何标记长期存活？","expandState":"expand"},"children":[{"data":{"id":"bt1hyqcaai00","created":1554019577572,"text":"为对象增加一个年龄计数器"},"children":[]},{"data":{"id":"bt1hz2t19940","created":1554019604706,"text":"Eden中对象经过第一次Minor GC后存活，且可被Survivor区容纳\n，就被移动到Survivor区，对象年龄设为1","expandState":"expand"},"children":[{"data":{"id":"bt1i0jk36lk0","created":1554019719535,"text":"Survivor中的对象每经过一次Minor GC，年龄计数器加一"},"children":[]},{"data":{"id":"bt1i1bt9fl40","created":1554019781039,"text":"年龄达到阈值后，被移动到老年代（阈值默认15）","note":"对象晋升到老年代的年龄阈值，可以通过参数` -XX:MaxTenuringThreshold `来设置"},"children":[]}]},{"data":{"id":"bt1i9cubxkw0","created":1554020410194,"text":"Survivor区如果无法容纳从Eden区转移过来的对象，就会提前通过分配担保机制提前转移到老年代去"},"children":[]},{"data":{"id":"bt1i2oi2s800","created":1554019887025,"text":"也不一定要达到年龄阈值才被移动到老年代"},"children":[{"data":{"id":"bt1i3fslecw0","created":1554019946434,"text":"Survivor 空间中相同年龄所有对象大小的总和大于 Survivor 空间的一半，\n年龄大于或等于该年龄的对象就可以直接进入老年代"},"children":[]}]}]}]}]}]},{"data":{"id":"bt1ian69waw0","created":1554020511048,"text":"Minor GC和Major GC","expandState":"collapse"},"children":[{"data":{"id":"bt1iautmes00","created":1554020527698,"text":"新生代GC（Minor GC）"},"children":[{"data":{"id":"bt1iba970ps0","created":1554020561291,"text":"发生在新生代的垃圾回收操作"},"children":[]},{"data":{"id":"bt1ibikjoeg0","created":1554020579392,"text":"速度较快"},"children":[]},{"data":{"id":"bt1ibokw2e00","created":1554020592473,"text":"回收频繁"},"children":[]}]},{"data":{"id":"bt1ib2k5v480","created":1554020544540,"text":"老年代GC（Major GC/Full GC）"},"children":[{"data":{"id":"bt1ic771bxc0","created":1554020632994,"text":"发生在老年代的垃圾回收操作"},"children":[]},{"data":{"id":"bt1iccso40o0","created":1554020645186,"text":"速度一般比Minor GC慢10倍"},"children":[]},{"data":{"id":"bt1ics106vk0","created":1554020678342,"text":"Major GC经常会伴随至少一次的Minor GC"},"children":[]}]}]},{"data":{"id":"bt1iq47chgw0","created":1554021723581,"text":"GC问题如何回答？","hyperlink":"https://icyfenix.iteye.com/blog/715301","hyperlinkTitle":"怎么在面试时回答Java垃圾回收机制（GC）相关问题（出自周志明的博客）"},"children":[]}]},"template":"default","theme":"fresh-blue","version":"1.4.43"}