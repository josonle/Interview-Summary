{"root":{"data":{"id":"c29691935198","created":1552977670,"text":"锁","hyperlink":"https://www.cnblogs.com/qifengshi/p/6831055.html","hyperlinkTitle":"参考"},"children":[{"data":{"id":"bsr8xgwpad40","created":1552978489119,"text":"乐观锁与悲观锁（并非锁的类型）","note":"不是锁的类型，而是看待并发的一种态度\n\n> 悲观锁在Java中的使用，就是利用各种锁。\n乐观锁在Java中的使用，是无锁编程，常常采用的是CAS算法，典型的例子就是原子类，通过CAS自旋实现原子操作的更新。"},"children":[{"data":{"id":"bsr8xlu6kbc0","created":1552978499850,"text":"悲观锁","note":"对并发冲突保持悲观态度，**强调只有获取锁才能访问数据**\n> 会增加很多额外的开销，也增加了死锁的几率。尤其是对于读操作，不会修改数据，使用悲观锁大大增加系统的响应时间\n\n传统数据库就是采取悲观锁"},"children":[]},{"data":{"id":"bsr8xobr7a80","created":1552978505267,"text":"乐观锁","note":"乐观锁认为并发冲突发生的可能性低，所以采取最后提交数据时才获取锁\n> 死锁的几率比较低，但是如果有多个事务同时处理相同数据也有几率会冲突甚至导致系统异常"},"children":[]},{"data":{"id":"bsra3bu4f080","created":1552981769374,"text":"悲观锁适合写操作非常多的场景，乐观锁适合读操作非常多的场景，不加锁会带来大量的性能提升"},"children":[]}]},{"data":{"id":"bsr93o59hdk0","created":1552978975059,"text":"可重入锁","note":"> 一种递归无阻塞的同步机制，可以在外层方法已经加锁的情况下，让内层方法再次获取锁\n\n"},"children":[{"data":{"id":"bsr94vzyhn40","created":1552979070517,"text":"ReentrantLock","note":"ReentrantLock维持了一个计数器，加锁一次计数器加一，释放锁就减一"},"children":[]},{"data":{"id":"bsr94zv2brc0","created":1552979078928,"text":"synchronized"},"children":[]},{"data":{"id":"bsrcveq276w0","created":1552989612075,"text":"读写锁"},"children":[]},{"data":{"id":"bsra14noqcg0","created":1552981597019,"text":"好处是可以一定程度避免死锁"},"children":[]}]},{"data":{"id":"bsr93krbpns0","created":1552978967686,"text":"自旋锁","note":"尝试获取锁的线程**不会立即阻塞**，而是会空循环去尝试获取锁，如果能获取锁就立即获取返回，否则就挂起等待\n\n> 自旋不是阻塞，自旋等待也不能代替阻塞\n\n> 自旋是在轻量级锁中使用的，在重量级锁中，线程不使用自旋\n\njdk1.6默认开启了自旋锁，还引入了**自适应的自旋锁**（自旋的时间不固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定）\n> 如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功，进而它将允许自旋等待持续相对更长的时间，比如100次循环。另外，如果对于某个锁，自旋很少成功获得过，那在以后要获取这个锁时将可能省略掉自旋过程，以避免浪费处理器资源\nhttps://blog.csdn.net/u013256816/article/details/51204385 \n","priority":1},"children":[{"data":{"id":"bsr9ipksw4o0","created":1552980153638,"text":"优点是减少线程上下文切换的开销"},"children":[]},{"data":{"id":"bsr9j1am1600","created":1552980179143,"text":"缺点是耗费cpu时间"},"children":[]},{"data":{"id":"bsr9kib54gg0","created":1552980294545,"text":"适合线程竞争不激烈，线程任务执行时间短的情况","note":"> 自旋锁适用于竞争不激烈且线程任务执行时间短的场景。但是对于竞争激烈或者任务执行时间长的场景，不适合使用自旋锁，否则会浪费 CPU 时间片"},"children":[]},{"data":{"id":"bsrav3o2elk0","created":1552983945790,"text":"自旋锁只有在多核CPU上有效果，单核毫无效果，只是浪费时间","note":"单cpu无效，因为基于cas的轮询会占用cpu,导致无法做线程切换"},"children":[]}]},{"data":{"id":"bsr9qvknvmg0","created":1552980793603,"text":"独享锁与共享锁","note":"从字面意思也能看出，独享就是一个线程占用一把锁，共享是多个线程可持有一把锁\n\n独享锁/共享锁就是一种广义的说法，互斥锁/读写锁就是具体的实现","priority":2},"children":[{"data":{"id":"bsr9r92eimw0","created":1552980822974,"text":"互斥锁"},"children":[{"data":{"id":"bsr9s99zvm80","created":1552980901798,"text":"ReentrantLock"},"children":[]},{"data":{"id":"bsr9se0ka7s0","created":1552980912111,"text":"synchronized"},"children":[]},{"data":{"id":"bsr9sh39tns0","created":1552980918805,"text":"(下面的)写锁"},"children":[]}]},{"data":{"id":"bsr948suhwg0","created":1552979020021,"text":"读写锁"},"children":[{"data":{"id":"bsr99lvl9zc0","created":1552979440306,"text":"ReadWriteLock"},"children":[{"data":{"id":"bsr9790q5pc0","created":1552979255590,"text":"ReentrantReadWriteLock"},"children":[]}]},{"data":{"id":"bsr97kyls4o0","created":1552979281583,"text":"提供读锁和写锁两把锁，读时用读锁，写时用写锁","note":"```\nReadWriteLock lock = new ReentrantReadWriteLock();\nLock readLock = lock.readLock();\nLock writeLock = lock.writeLock();\n```"},"children":[]},{"data":{"id":"bsr983bkhog0","created":1552979321549,"text":"读操作可同时进行，但写操作时只允许一个写","note":"> 如果写锁没有加锁，则读锁不会阻塞，否则需要等待写入完成\n"},"children":[{"data":{"id":"bsr9ul6b7ds0","created":1552981084424,"text":"读锁（共享锁）"},"children":[]}]}]}]},{"data":{"id":"bsraznbbwb40","created":1552984302012,"text":"自旋锁和互斥锁综合","hyperlink":"http://ifeve.com/practice-of-using-spinlock-instead-of-mutex/","hyperlinkTitle":"自旋锁代替互斥锁的实践"},"children":[{"data":{"id":"bsrazyezqc00","created":1552984326178,"text":"混合型自旋锁","note":"起初表现的和正常自旋锁一样，如果无法获取互斥锁，它也许会放弃该线程的执行，并允许其他线程执行"},"children":[]},{"data":{"id":"bsrb0a2tbug0","created":1552984351563,"text":"混合型互斥锁","note":"在多核系统上起初表现的像自旋锁一样， 如果一个线程不能获取互斥锁， 它不会马上被切换为休眠状态，在一段时间依然无法获取锁，进行睡眠状态"},"children":[]}]},{"data":{"id":"bsr93r44x400","created":1552978981521,"text":"轮询锁与定时锁"},"children":[{"data":{"id":"bsr9b3qnozs0","created":1552979557553,"text":"通过线程不断尝试获取锁，可避免发送死锁"},"children":[]},{"data":{"id":"bsr9bdm6xeg0","created":1552979579051,"text":"java中锁的tryLock方法"},"children":[{"data":{"id":"bsr9bnk3cjk0","created":1552979600692,"text":"可以指定一个时间参数，即定时锁"},"children":[{"data":{"id":"bsr9bwrglbc0","created":1552979620729,"text":"在给定时间内尝试获取锁返回，超时就返回"},"children":[]}]}]}]},{"data":{"id":"bsr9wkmequo0","created":1552981239949,"text":"公平锁与非公平锁","note":"公平锁：多个线程在等待同一个锁时，按照申请锁的先后顺序来获得锁\n\n非公平锁：不是按先后顺序，可以依据优先级高低来抢占锁。**可能产生饥饿**"},"children":[{"data":{"id":"bsr9zjlhnaw0","created":1552981472809,"text":"默认ReentrantLock和synchronized是非公平锁"},"children":[]},{"data":{"id":"bsr9ztu8pb40","created":1552981495106,"text":"new ReentrantLock(true)可以实现公平锁"},"children":[]}]},{"data":{"id":"bsra66b3aq00","created":1552981992432,"text":"锁的状态","note":"随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级到重量级锁\n> 有的地方说锁只能升级，不能降级；也有地方说可以降级"},"children":[{"data":{"id":"bsrb66ebcy00","created":1552984813737,"text":"无锁状态"},"children":[]},{"data":{"id":"bsrb693b3080","created":1552984819601,"text":"偏向锁"},"children":[]},{"data":{"id":"bsrb6caf76o0","created":1552984826562,"text":"轻量级锁"},"children":[]},{"data":{"id":"bsrb6o7xz2o0","created":1552984852533,"text":"重量级锁"},"children":[]}]},{"data":{"id":"bsrcc8exqig0","created":1552988109423,"text":"类锁和对象锁","note":"- 一个类可以有多个对象锁，但只能有一个类锁\n\n- 对象锁 锁住对象，防止其他线程同时调用加对象锁的方法、块\n> 对于一个对象，线程进入synchronized方法的时候获取该对象的锁，当然如果已经有线程获取了这个对象的锁，那么当前线程会等待；synchronized方法正常返回或者抛异常而终止，JVM会自动释放对象锁\n\n- 类锁 锁住Class对象，防止线程同时调用加类锁的方法、块\n\n```\npublic class SynchronizedTest\n{    public synchronized void method1(){}\n    public synchronized void method2(){}\n    public static synchronized void method3(){}\n    public static synchronized void method4(){}\n}\n```\n那么，有SynchronizedTest的两个实例a和b，对于一下的几个选项有哪些能被一个以上的线程同时访问呢？  \nA. a.method1() vs. a.method2()  \nB. a.method1() vs. b.method1()  \nC. a.method3() vs. b.method4()  \nD. a.method3() vs. b.method3()  \nE. a.method1() vs. a.method3()  \n答案是什么呢？BE\n> method1和method2都是对象锁，method3和method4都是类锁，A选项中两个方法使用的是一个对象锁，所以不能同时访问；B选项中两个方法使用的是两个对象的对象锁，所以可以同时访问；C、D选项的两个方法都是使用的一个类锁，所以不能同时访问；E选项中的两个方法一个是对象锁，一个是类锁，所以可以同时访问","hyperlink":"https://github.com/HotBitmapGG/AndroidInterview/blob/master/java/[Java]%20%E6%96%B9%E6%B3%95%E9%94%81%E3%80%81%E5%AF%B9%E8%B1%A1%E9%94%81%E5%92%8C%E7%B1%BB%E9%94%81%E7%9A%84%E6%84%8F%E4%B9%89%E5%92%8C%E5%8C%BA%E5%88%AB.md","hyperlinkTitle":""},"children":[{"data":{"id":"bsrcce7nbz40","created":1552988122043,"text":"类锁","note":"- 方法上加了static synchronized修饰\n- synchronized(XXX.class){}\n\n只有这两种"},"children":[]},{"data":{"id":"bsrccfw4jv40","created":1552988125699,"text":"对象锁","note":"- synchronized修饰非静态方法\n- synchronized(this){}代码块\n只有这两类"},"children":[]}]}]},"template":"default","theme":"fresh-blue","version":"1.4.43"}