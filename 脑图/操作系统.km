{"root":{"data":{"id":"bt6i9lvtya80","created":1554528229659,"text":"操作系统","hyperlink":"https://xiaoxiyouran.github.io/blogger/docs/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E9%9D%A2%E8%AF%95%E5%B8%B8%E9%97%AE/20180829_%E5%B8%B8%E9%97%AE%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E9%87%8D%E9%9A%BE%E7%82%B9%E6%80%BB%E7%BB%93.html#%E9%A2%98%E7%BA%B2","hyperlinkTitle":""},"children":[{"data":{"id":"bt6ibfrlon40","created":1554528373071,"text":"四大特效"},"children":[{"data":{"id":"bt6ibp7zsow0","created":1554528393653,"text":"并发"},"children":[]},{"data":{"id":"bt6ibqmw3eg0","created":1554528396731,"text":"共享"},"children":[]},{"data":{"id":"bt6ibs1g7k00","created":1554528399788,"text":"虚拟"},"children":[{"data":{"id":"bt6inrcvx4w0","created":1554529338673,"text":"通过时分复用（如分时系统）以及空分复用（如虚拟内存）技术实现把一个物理实体虚拟为多个"},"children":[]}]},{"data":{"id":"bt6ibt3kleo0","created":1554528402093,"text":"异步"},"children":[]}]},{"data":{"id":"bt6j5y6zw7c0","created":1554530764109,"text":"主要功能"},"children":[{"data":{"id":"bt6j63gvvqo0","created":1554530775591,"text":"进程管理","expandState":"expand"},"children":[{"data":{"id":"bt6j92pocmg0","created":1554531009038,"text":"进程控制"},"children":[]},{"data":{"id":"bt6j95ddzso0","created":1554531014825,"text":"进程同步"},"children":[]},{"data":{"id":"bt6j98afjz40","created":1554531021177,"text":"进程通信"},"children":[]},{"data":{"id":"bt6j9a16t3k0","created":1554531024972,"text":"进程调度"},"children":[]}]},{"data":{"id":"bt6j6f6jggg0","created":1554530801087,"text":"存储器管理","expandState":"expand"},"children":[{"data":{"id":"bt6j8ihw6cw0","created":1554530965032,"text":"内存分配"},"children":[]},{"data":{"id":"bt6j8lgfmwg0","created":1554530971474,"text":"内存保护"},"children":[]},{"data":{"id":"bt6j8nmee8w0","created":1554530976188,"text":"地址映射"},"children":[]},{"data":{"id":"bt6j8szoh740","created":1554530987875,"text":"内存扩充"},"children":[]}]},{"data":{"id":"bt6j6hoikbs0","created":1554530806527,"text":"设备管理","note":"管理所有外围设备，包括完成用户的IO请求；为用户进程分配IO设备；提高IO设备利用率；提高IO速度；方便IO的使用"},"children":[]},{"data":{"id":"bt6j6jqr7800","created":1554530811016,"text":"文件管理","note":"管理用户文件和系统文件，方便使用同时保证安全性。包括：磁盘存储空间管理，目录管理，文件读写管理以及文件共享和保护"},"children":[]},{"data":{"id":"bt6j6t0teso0","created":1554530831216,"text":"提供用户接口","expandState":"collapse"},"children":[{"data":{"id":"bt6j71rs8d40","created":1554530850260,"text":"程序接口API"},"children":[]},{"data":{"id":"bt6j7552azk0","created":1554530857594,"text":"用户界面接口GUI"},"children":[]}]}]},{"data":{"id":"bt6je9eddhs0","created":1554531415413,"text":"进程管理相关","expandState":"collapse"},"children":[{"data":{"id":"bt6jedio65c0","created":1554531424380,"text":"进程状态及切换"},"children":[]},{"data":{"id":"bt6jeivlwk80","created":1554531436046,"text":"进程和线程区别"},"children":[]},{"data":{"id":"bt6jpn08umo0","created":1554532307039,"text":"进程通信","expandState":"collapse"},"children":[{"data":{"id":"bt6jpoy04l40","created":1554532311257,"text":"共享内存"},"children":[{"data":{"id":"bt6jqiqn8bs0","created":1554532376116,"text":"共享内存比消息传递快，但消息传递更容易实现"},"children":[]},{"data":{"id":"bt6jr805o2o0","created":1554532431111,"text":"用户进程空间独立，所以共享内存需要通过特殊的系统调用实现。但线程可以自然的共享进程的空间"},"children":[]},{"data":{"id":"bt6jsix3uaw0","created":1554532533235,"text":"对共享空间的操作需要提供同步互斥操作（PV操作）"},"children":[]}]},{"data":{"id":"bt6jpr62hy80","created":1554532316099,"text":"消息传递"},"children":[{"data":{"id":"bt6jul4v4uw0","created":1554532694786,"text":"进程通过系统提供的发送消息和接收消息两个原语进行数据交换"},"children":[]},{"data":{"id":"bt6juowtytc0","created":1554532703007,"text":"直接通信","note":"发送进程直接把消息发送给接收进程，并将它挂在接收进程的消息缓冲队列上，接收进程从消息缓冲队列中取得消息"},"children":[]},{"data":{"id":"bt6juubit2w0","created":1554532714780,"text":"间接通信","note":"发送进程把消息发送到某个中间实体中，接收进程从中间实体中取得消息。这种中间实体一般称为信箱，这种通信方式又称为信箱通信方式。该通信方式广泛应用于计算机网络中，相应的通信系统称为电子邮件系统"},"children":[]}]},{"data":{"id":"bt6jpv9tu0o0","created":1554532325033,"text":"管道通信","note":"管道通信是消息传递的一种特殊方式。所谓“管道”，是指用于连接一个读进程和一个写进程以实现它们之间通信的一个共享文件，又名pipe文件。向管道（共享文件）提供输入的发送进程（即写进程），以字符流形式将大量的数据送入（写）管道；而接收管道输出的接收进程（即读进程），则从管道中接收（读）数据。为了协调双方的通信，管道机制必须提供以下三方面的协调能力：互斥、同步和确定对方的存在"},"children":[]}]},{"data":{"id":"bt6k13j4fhc0","created":1554533205015,"text":"进程同步","expandState":"expand"},"children":[{"data":{"id":"bt6k16zepso0","created":1554533212530,"text":"用于确保共享同一逻辑地址空间的协作进程可以有序地执行，\n从而维护数据的一致性"},"children":[]},{"data":{"id":"bt6k21gmrxs0","created":1554533278875,"text":"问题"},"children":[{"data":{"id":"bt6k24aa4a80","created":1554533285022,"text":"临界区问题"},"children":[]},{"data":{"id":"bt6k26vyvog0","created":1554533290686,"text":"读者-写者问题"},"children":[]},{"data":{"id":"bt6k2etlgtc0","created":1554533307957,"text":"哲学家进餐问题"},"children":[]}]},{"data":{"id":"bt6k2jms9nk0","created":1554533318429,"text":"解决"},"children":[{"data":{"id":"bt6k2m5xwbc0","created":1554533323941,"text":"管程"},"children":[]},{"data":{"id":"bt6k2uay5cg0","created":1554533341658,"text":"信号量"},"children":[]},{"data":{"id":"bt6k3ua2g480","created":1554533419969,"text":"原子操作"},"children":[]}]}]},{"data":{"id":"bt6kbspa3sw0","created":1554534043449,"text":"进程调度","expandState":"expand"},"children":[{"data":{"id":"bt6kbvcjg6g0","created":1554534049209,"text":"FCFS先来先服务"},"children":[{"data":{"id":"bt6kc0c4wq80","created":1554534060068,"text":"平均等待时间较长"},"children":[]},{"data":{"id":"bt6kcwogce00","created":1554534130470,"text":"护航效果"},"children":[]},{"data":{"id":"bt6kd1dqt0g0","created":1554534140706,"text":"非抢占的"},"children":[]}]},{"data":{"id":"bt6kd56yidc0","created":1554534149003,"text":"SJF最短作业优先"},"children":[{"data":{"id":"bt6kdibs8og0","created":1554534177593,"text":"最佳，但问题是无法确定下一CPU区间长度"},"children":[{"data":{"id":"bt6keeosq480","created":1554534248037,"text":"平均等待时间最短"},"children":[]}]},{"data":{"id":"bt6kekg2mf40","created":1554534260570,"text":"常用于长期调度"},"children":[]},{"data":{"id":"bt6ketb6dtk0","created":1554534279865,"text":"抢占和非抢占"},"children":[{"data":{"id":"bt6kf46xa5c0","created":1554534303553,"text":"抢占的是最短剩余时间优先调度。\n新到达的进程的CPU区间比当前运行进程的剩余时间更短，则让出CPU使用权"},"children":[]}]},{"data":{"id":"bt6kgkubua80","created":1554534418161,"text":"可看做简单的优先级调度，按照CPU区间为优先级"},"children":[]}]},{"data":{"id":"bt6kh5bwhsg0","created":1554534462759,"text":"优先级调度"},"children":[{"data":{"id":"bt6kkjp6x6w0","created":1554534729130,"text":"可以是抢占，也可以是非抢占的"},"children":[]},{"data":{"id":"bt6kkxp00r40","created":1554534759593,"text":"存在问题"},"children":[{"data":{"id":"bt6kl0kqj0g0","created":1554534765866,"text":"低优先级进程会发生“饥饿”（无穷阻塞）"},"children":[]},{"data":{"id":"bt6km5ogbfk0","created":1554534855339,"text":"解决","expandState":"expand"},"children":[{"data":{"id":"bt6kmjqmlb40","created":1554534885945,"text":"老化：逐渐增加长时间等待进程的优先级"},"children":[]}]}]}]},{"data":{"id":"bt6kn5yxbeo0","created":1554534934336,"text":"RR轮转法调度"},"children":[{"data":{"id":"bt6knfenk4w0","created":1554534954878,"text":"在FCFS基础上增加时间片概念，每个进程每次执行时间不超过一个CPU时间片长度"},"children":[]},{"data":{"id":"bt6koqmneio0","created":1554535057670,"text":"进程会被保存到一个FIFO的就绪队列中"},"children":[]},{"data":{"id":"bt6kozglgf40","created":1554535076895,"text":"抢占的"},"children":[]}]},{"data":{"id":"bt6kpk4e4nk0","created":1554535121870,"text":"多级队列调度"},"children":[{"data":{"id":"bt6kpptcjyo0","created":1554535134263,"text":"进程依据属性被分配到不同的调度队列中"},"children":[]},{"data":{"id":"bt6kq0e4iv40","created":1554535157287,"text":"不同调度队列中使用不同的调度算法"},"children":[{"data":{"id":"bt6kqatly340","created":1554535179991,"text":"比如前台进程采用RR，后台进程采用FCFS"},"children":[]}]},{"data":{"id":"bt6kqqjuxy00","created":1554535214230,"text":"队列间也有调度，通常是用固定优先级抢占调度"},"children":[]}]},{"data":{"id":"bt6krwthpu80","created":1554535306237,"text":"多级反馈队列调度"},"children":[{"data":{"id":"bt6ksfm26600","created":1554535347147,"text":"允许进程在队列间移动"},"children":[]},{"data":{"id":"bt6kttkjmdk0","created":1554535455894,"text":"根据不同CPU区间的特点来区分进程"},"children":[{"data":{"id":"bt6ku70lr680","created":1554535485163,"text":"如果进程使用过多CPU时间，那就会被移入更低优先级队列"},"children":[]},{"data":{"id":"bt6kv1ampqg0","created":1554535551073,"text":"较低优先级队列中等待时间过长的进程会被转移到更高优先级队列（老化）"},"children":[]}]}]}]},{"data":{"id":"bt6k6obp0xc0","created":1554533642099,"text":"用户态和内核态","expandState":"collapse"},"children":[{"data":{"id":"bt6k6v895vs0","created":1554533657129,"text":"用户态切换到内核态的三种可能"},"children":[{"data":{"id":"bt6k7a2dhuw0","created":1554533689425,"text":"系统调用"},"children":[{"data":{"id":"bt6k8mzc7mg0","created":1554533795904,"text":"主动切换"},"children":[]}]},{"data":{"id":"bt6k73mxusg0","created":1554533675431,"text":"异常","note":"当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常"},"children":[]},{"data":{"id":"bt6k76guhf40","created":1554533681593,"text":"中断","note":"当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等"},"children":[]}]}]},{"data":{"id":"bt6kxzur77k0","created":1554535783029,"text":"死锁问题","expandState":"expand"},"children":[{"data":{"id":"bt6ky2yu0c00","created":1554535789806,"text":"死锁原因"},"children":[{"data":{"id":"bt6kyq12le80","created":1554535840007,"text":"竞争同一资源的进程数大于可用资源数"},"children":[]},{"data":{"id":"bt6kzhosri00","created":1554535900215,"text":"进程推进顺序非法，申请和释放资源顺序不合理"},"children":[]}]},{"data":{"id":"bt6m33b51m00","created":1554539003481,"text":"死锁产生的必要条件"},"children":[{"data":{"id":"bt6m3c75tmg0","created":1554539022831,"text":"互斥：进程对分配的资源采取排他"},"children":[]},{"data":{"id":"bt6m4799meo0","created":1554539090439,"text":"占有并等待：进程被阻塞时不释放锁申请的资源"},"children":[]},{"data":{"id":"bt6m5yj228g0","created":1554539228168,"text":"不可抢占：进程对于已经申请到的资源在使用完成之前不可被抢占"},"children":[]},{"data":{"id":"bt6m6n0sn0w0","created":1554539281483,"text":"循环等待：发生死锁的时候存在的一个 进程-资源 环形等待链"},"children":[]}]},{"data":{"id":"bt6m9gj1fvc0","created":1554539502442,"text":"死锁解决"},"children":[{"data":{"id":"bt6m9ja4eiw0","created":1554539508434,"text":"死锁预防"},"children":[{"data":{"id":"bt6ma7nc8ew0","created":1554539561475,"text":"破坏死锁的某几个必要条件"},"children":[]}]},{"data":{"id":"bt6m9lp9xd40","created":1554539513702,"text":"死锁避免"},"children":[{"data":{"id":"bt6mamnekdc0","created":1554539594130,"text":"在资源的动态分配中，防止系统进入不安全状态(可能产生死锁的状态)"},"children":[]}]},{"data":{"id":"bt6m9nxpwqg0","created":1554539518567,"text":"死锁检测和死锁解除"},"children":[{"data":{"id":"bt6m9y1xrk80","created":1554539540589,"text":"分支主题"},"children":[]}]}]}]}]},{"data":{"id":"bt6racjly0g0","created":1554553677683,"text":"内存分配"},"children":[{"data":{"id":"bt6ql5ngk9k0","created":1554551703574,"text":"连续内存分配","expandState":"expand"},"children":[{"data":{"id":"bt6qls7v7hc0","created":1554551752697,"text":"主要是动态分区分配"},"children":[]},{"data":{"id":"bt6qmra92js0","created":1554551829028,"text":"首次适应First Fit","note":"快"},"children":[{"data":{"id":"bt6qnpgnn000","created":1554551903426,"text":"空闲分区以地址递增的次序链接"},"children":[]},{"data":{"id":"bt6qnvkrjg00","created":1554551916735,"text":"内存分配时顺序查找，选择第一个满足的分区"},"children":[]}]},{"data":{"id":"bt6qmz1aeuo0","created":1554551845901,"text":"最佳适应Best Fit","note":"慢，但是内存利用率高"},"children":[{"data":{"id":"bt6qou86dxk0","created":1554551992162,"text":"空闲分区按容量递增形成分区链"},"children":[]},{"data":{"id":"bt6qovorh2w0","created":1554551995341,"text":"内存分配时找寻第一个适合的空闲分区"},"children":[]}]},{"data":{"id":"bt6qn6exkrs0","created":1554551861963,"text":"最坏适应Worest Fit","note":"选最大的分区，可以产生最大剩余孔"},"children":[{"data":{"id":"bt6qncidffk0","created":1554551875232,"text":"空闲分区以容量递减的次序链接"},"children":[]},{"data":{"id":"bt6qpdfxpqw0","created":1554552033990,"text":"找寻第一个适合的空闲分区（就是挑最大的分区）"},"children":[]}]},{"data":{"id":"bt6qum0wcl40","created":1554552444492,"text":"碎片问题","note":"外部碎片和内部碎片的区别：这个我很难讲清楚，*内部碎片*是空闲空间分配给某个进程后*剩下来的空缺*碎片，而*外部碎片*是空闲空间不够分配（*没有分配出去的，但由于太小了无法分配给申请内存空间的新进程的内存空闲区域*）。可以看下【[外部碎片和内部碎片的区别](http://www.cnblogs.com/sjlove/archive/2013/06/05/3119683.html)】"},"children":[{"data":{"id":"bt6qupnrt540","created":1554552452406,"text":"外部碎片"},"children":[{"data":{"id":"bt6quxzyvds0","created":1554552470557,"text":"首次适应、最佳适应"},"children":[]},{"data":{"id":"bt6r27fz23k0","created":1554553039665,"text":"解决方法"},"children":[{"data":{"id":"bt6r2acarbs0","created":1554553045974,"text":"紧缩"},"children":[{"data":{"id":"bt6r8xtnmqw0","created":1554553567274,"text":"移动内存内容，将空闲空间移到一端合并成一整块"},"children":[]},{"data":{"id":"bt6r9ng3h3s0","created":1554553623051,"text":"仅适合重定位是动态并在运行试可采用"},"children":[]}]},{"data":{"id":"bt6r2eb3zfs0","created":1554553054609,"text":"使用非连续内存空间分配方法——分页和分段"},"children":[]}]}]},{"data":{"id":"bt6qusvjvu80","created":1554552459407,"text":"内部碎片","note":"占有这些区域或页面的进程并不使用这个存储块。而在进程占有这块存储块时，系统无法利用它。直到进程释放它，或进程结束时，系统才有可能利用这个存储块"},"children":[{"data":{"id":"bt7a0tyl9eg0","created":1554606533040,"text":"三种适应方法都会产生内部碎片"},"children":[]}]}]}]},{"data":{"id":"bt6rbk22v2w0","created":1554553772401,"text":"内存非连续分配","expandState":"expand"},"children":[{"data":{"id":"bt6re2pug340","created":1554553969748,"text":"分页","expandState":"expand"},"children":[{"data":{"id":"bt6s73y4mfs0","created":1554556244987,"text":"将物理内存分为固定大小的块，称为帧；逻辑内存分为同样大小的块，称为页"},"children":[]},{"data":{"id":"bt6s8lcw3a80","created":1554556361249,"text":"页表：完成页和帧的映射"},"children":[{"data":{"id":"bt6s9eqv3s00","created":1554556425220,"text":"页表包含每页所在物理内存的基地址（帧号×页大小，帧号是页表中页号对应的）"},"children":[]},{"data":{"id":"bt6scl1gdpc0","created":1554556674014,"text":"物理地址=物理内存基地址+页偏移"},"children":[]},{"data":{"id":"bt6sd832urs0","created":1554556724178,"text":"像逻辑地址空间2^m，页大小2^n，则逻辑地址的高m-n位为页号，低n位为页偏移","note":"如：页大小4B，物理内存32B，所以可分为8页。页偏移2位（2^2=4），页号3位（2^5=32,5-2=3）。所以逻辑地址5（00101）表示页号1，页偏移1。如果页表中页号1对应帧号3的话，则物理地址为3×4+1=13"},"children":[]}]},{"data":{"id":"bt6sk0xo7rk0","created":1554557257163,"text":"分页不会产生外部碎片，但会导致内部碎片"},"children":[]},{"data":{"id":"bt6swddjcx40","created":1554558224614,"text":"页表是存储在内存中的，所以访问分页系统中内存数据需要两次内存访问"},"children":[{"data":{"id":"bt6syo13o8w0","created":1554558404535,"text":"所以就有下面的TLB机制"},"children":[]}]},{"data":{"id":"bt6smirsd600","created":1554557452718,"text":"计算机提供一种TLB（转换表缓存区）机制，存储访问过的页号和帧号"},"children":[{"data":{"id":"bt6soe51nf40","created":1554557599364,"text":"先从TLB中查找，TLB命中，命中率；\nTLB失效的话，会访问页表，同时将页表中的该映射表项添加到TLB中","layout_left_offset":{"x":24,"y":19},"note":"![1554607303208.png](https://i.loli.net/2019/04/07/5ca96cd463782.png)"},"children":[]}]},{"data":{"id":"bt6t09rjljs0","created":1554558530210,"text":"如果内存的逻辑地址很大，将会导致程序的页表项会很多，\n所以要更大的连续内存空间用来存储页表"},"children":[{"data":{"id":"bt6t0buidew0","created":1554558534743,"text":"两级页表和多级页表"},"children":[]}]}]},{"data":{"id":"bt6re4o432w0","created":1554553973997,"text":"分段"},"children":[]},{"data":{"id":"bt7akb2u0uw0","created":1554608059221,"text":"分页和分段区别"},"children":[{"data":{"id":"bt7akm165og0","created":1554608083065,"text":"页是信息的物理单位，是为了提高内存利用率；\n段是信息的逻辑单位，是为了满足程序员的一些逻辑需求(比如数据共享，数据保护，动态链接等)"},"children":[]},{"data":{"id":"bt7amlkm1y00","created":1554608238792,"text":"页的大小固定由系统分配决定，段大小不固定由写代码的决定"},"children":[]}]}]}]},{"data":{"id":"bt7apqwyoww0","created":1554608485516,"text":"虚拟内存"},"children":[{"data":{"id":"bt7ar6y7kdc0","created":1554608598784,"text":"当前内存空间无法同时装下一个或多个程序，导致程序无法运行，可以考虑从逻辑角度扩充内存容量","note":"> 基于局部性原理，在程序装入时，可以将程序的*一部分装入内存，而将其余部分留在外存*，就可以启动程序执行。在程序执行过程中，*当所访问的信息不在内存时，由操作系统将所需要的部分调入内存*,然后继续执行程序。另一方面，操作系统将内存中暂时不使用的内容换出到外存上，从而腾出空间存放将要调入内存的信息。这样，系统好像为用户提供了一个比实际内存大得多的存储器，称为虚拟存储器。"},"children":[]},{"data":{"id":"bt7aw4z3f7k0","created":1554608986304,"text":"虚拟存储器特征"},"children":[{"data":{"id":"bt7awbltjn40","created":1554609000739,"text":"多次性：一个作业可以分多次被调入内存"},"children":[]},{"data":{"id":"bt7awkh1l6g0","created":1554609020042,"text":"对换性：可换入也可换出"},"children":[]},{"data":{"id":"bt7ax0md4yg0","created":1554609055192,"text":"虚拟性：即逻辑上扩充内存容量"},"children":[]}]},{"data":{"id":"bt7b0gqn5u80","created":1554609325371,"text":"按需调页、写时复制"},"children":[]},{"data":{"id":"bt7b0ss23m80","created":1554609351578,"text":"调页算法"},"children":[]}]}]},"template":"default","theme":"fresh-blue","version":"1.4.43"}