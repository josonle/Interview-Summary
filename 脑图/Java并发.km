{"root":{"data":{"id":"f6d3645b2be9","created":1553407972,"text":"新建脑图"},"children":[{"data":{"id":"bsvh9ql2wzs0","created":1553408259260,"text":"线程状态"},"children":[]},{"data":{"id":"bsvhcqvr6ww0","created":1553408494998,"text":"线程创建","note":"> 实现 Runnable 和 Callable 接口的类只能当做一个可以在线程中运行的任务，不是真正意义上的线程，因此最后还需要通过 Thread 来调用 new Thread(xxx).start()"},"children":[{"data":{"id":"bsvhctc04dk0","created":1553408500334,"text":"继承Thread类"},"children":[]},{"data":{"id":"bsvhcwem1r40","created":1553408507022,"text":"实现Runnable接口"},"children":[]},{"data":{"id":"bsvhcz2u4740","created":1553408512840,"text":"实现Callable接口"},"children":[{"data":{"id":"bsvhdbbe7cw0","created":1553408539479,"text":"和Runnable接口区别"},"children":[{"data":{"id":"bsvhfvwqutk0","created":1553408741034,"text":"Callable可以有返回值，可以抛出异常","note":"通过FutureTask实例的get方法获取"},"children":[]}]},{"data":{"id":"bsvhdmocb5k0","created":1553408564207,"text":"多和Future、FutureTask合起来用"},"children":[]}]},{"data":{"id":"bsvhd2n2wog0","created":1553408520596,"text":"通过线程池"},"children":[]}]},{"data":{"id":"bsvhe7tb4o80","created":1553408610219,"text":"问题","expandState":"expand"},"children":[{"data":{"id":"bsvhe9xggzk0","created":1553408614824,"text":"Thread.sleep()和Object.wait()区别"},"children":[{"data":{"id":"bsvnfm7iucw0","created":1553425646577,"text":"可见sleep是Thread的静态方法，wait是Object方法"},"children":[]},{"data":{"id":"bsvnfy8ziq80","created":1553425672787,"text":"wait会释放锁，挂起；sleep不会，休眠"},"children":[]}]},{"data":{"id":"bsvngcyyum80","created":1553425704833,"text":"Object.notify()和Object.notifyAll()","note":"> 唤醒挂起的线程，只用于同步块、方法中，否则会在运行时抛出 IllegalMonitorStateException"},"children":[]},{"data":{"id":"bsvo52fgttk0","created":1553427640990,"text":"Condition类下的线程协调","note":"Condition对象通过Lock锁的newCondition()方法创建\n```\nLock lock = new ReentrantLock();\nCondition condition = lock.newCondition();\n```\n\n```java\npublic class AwaitSignalExample {\n\n    private Lock lock = new ReentrantLock();\n    private Condition condition = lock.newCondition();\n\n    public void before() {\n        lock.lock();\n        try {\n            System.out.println(\"before\");\n            condition.signalAll();\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    public void after() {\n        lock.lock();\n        try {\n            condition.await();\n            System.out.println(\"after\");\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } finally {\n            lock.unlock();\n        }\n    }\n}\n```"},"children":[{"data":{"id":"bsvo58bkhzk0","created":1553427653815,"text":"await()"},"children":[]},{"data":{"id":"bsvo5are7340","created":1553427659126,"text":"signal()和signalAll()方法"},"children":[]},{"data":{"id":"bsvoas22f6o0","created":1553428088597,"text":"挂起/唤醒，同上面，但可以指定条件更加灵活"},"children":[]}]},{"data":{"id":"bsvjbdagycg0","created":1553414029268,"text":"Thread.yeild()","note":"> 当前线程已经完成了生命周期中最重要的部分，可以*切换给其它线程来执行*。该方法只是对线程调度器的一个建议，而且也**只是*建议*具有相同优先级的其它线程可以运行**"},"children":[]},{"data":{"id":"bsvn9l0rjvs0","created":1553425173807,"text":"join()方法","note":"线程b中调用另一个线程对象a的join方法，然后将当前线程b挂起，而不是忙等待，直到另一个线程a执行完成才继续执行b"},"children":[]},{"data":{"id":"bsvjgkyt00w0","created":1553414437798,"text":"interrupt()和interrupted()方法"},"children":[{"data":{"id":"bsvjh15hcqg0","created":1553414473030,"text":"interrupt是用来中断线程"},"children":[{"data":{"id":"bsvjhh1cpvk0","created":1553414507609,"text":"如果该线程处于阻塞、有限期等待或者无限期等待状态，那么就会抛出 InterruptedException，从而提前结束该线程"},"children":[]},{"data":{"id":"bsvjjjlp0cg0","created":1553414669921,"text":"会设置线程的中断标记为true"},"children":[]},{"data":{"id":"bsvjhipi1v40","created":1553414511246,"text":"不能用来中断I/O阻塞和synchronized锁阻塞"},"children":[]}]},{"data":{"id":"bsvjisuwobk0","created":1553414611705,"text":"interrupted用来检测是否中断"},"children":[{"data":{"id":"bsvjjnyhhq80","created":1553414679402,"text":"检测线程的中断标志是否为true"},"children":[]}]}]},{"data":{"id":"bsvhkhdfpuo0","created":1553409101212,"text":"守护线程和非守护线程"},"children":[{"data":{"id":"bsvhl0hz5o80","created":1553409142846,"text":"守护线程是程序运行时在后台提供服务的线程，可有可无"},"children":[]},{"data":{"id":"bsvhl88yrhc0","created":1553409159715,"text":"可通过Thread对象的setDaemon(true)设置为守护线程"},"children":[]},{"data":{"id":"bsvhlib95uo0","created":1553409181621,"text":"非守护线程退出时会杀死守护线程"},"children":[]}]},{"data":{"id":"bsvlhaz0khc0","created":1553420136627,"text":"Synchronized和ReentrantLock区别"},"children":[{"data":{"id":"bsvlhgwlhy80","created":1553420149541,"text":"Synchronized是JVM实现的，ReentrantLock是JDK实现的"},"children":[]},{"data":{"id":"bsvlhzah2zk0","created":1553420189563,"text":"ReentrantLock锁可中断","note":"> ReentranLock可以等待中断，比如有的线程长期占有锁，等待线程可以选择放弃等待\nSynchronized不可中断"},"children":[]},{"data":{"id":"bsvljahcp9c0","created":1553420292287,"text":"Synchronized非公平锁，ReentrantLock可以设置为公平锁"},"children":[]},{"data":{"id":"bsvljtgazz40","created":1553420333583,"text":"ReentrantLock 可以同时绑定多个 Condition 条件对象"},"children":[]},{"data":{"id":"bsvljx12ths0","created":1553420341369,"text":"性能问题","note":"java老版本时，synchronized是重量级锁，jdk 1.6后优化了synchronized，引入了偏向锁、轻量级锁、重量级锁"},"children":[]}]}]},{"data":{"id":"bsvjty4pryo0","created":1553415485188,"text":"JUC包","hyperlink":"http://www.cnblogs.com/skywang12345/p/java_threads_category.html","hyperlinkTitle":""},"children":[{"data":{"id":"bsvno1hwsbc0","created":1553426306771,"text":"Executor框架","image":"https://images2015.cnblogs.com/blog/879896/201606/879896-20160624162220547-1137214388.jpg","imageTitle":"","imageSize":{"width":200,"height":122},"expandState":"expand","hyperlink":"https://segmentfault.com/a/1190000016586578","hyperlinkTitle":""},"children":[{"data":{"id":"bsvjwgvi8eg0","created":1553415682718,"text":"Executor接口","expandState":"expand","note":"只定义了一个方法`void execute(Runnable command);`\n```\nExecutor executor = someExecutor;       // 创建具体的Executor对象\nexecutor.execute(new RunnableTask1());//执行任务\n```\n\n```\n//同步执行任务\nclass DirectExecutor implements Executor {   \n    public void execute(Runnable r) {\n        r.run();\n    }\n}\n//异步执行任务\n//对于每个任务，执行器都会创建一个新的线程去执行任务\nclass ThreadPerTaskExecutor implements Executor {\n    public void execute(Runnable r) {\n        new Thread(r).start();\n    }\n}\n```\n\n三种Executor：\nCachedThreadPool：一个任务创建一个线程；\nFixedThreadPool：所有任务只能使用固定大小的线程；\nSingleThreadExecutor：相当于大小为 1 的 FixedThreadPool"},"children":[{"data":{"id":"bsvhkfqix9k0","created":1553409097650,"text":"ExecutorService接口","resource":["实现Executor"],"expandState":"collapse"},"children":[{"data":{"id":"bsvjljk5ic00","created":1553414826556,"text":"shutdown()和shutdownNow()"},"children":[{"data":{"id":"bsvkdvc0pl40","created":1553417046382,"text":"shutdown"},"children":[{"data":{"id":"bsvkdqc3hp40","created":1553417035503,"text":"关闭线程池，已提交的任务继续执行，不接受继续提交新任务"},"children":[]}]},{"data":{"id":"bsvkdy34kvc0","created":1553417052375,"text":"shutdownNow"},"children":[{"data":{"id":"bsvkef7h66w0","created":1553417089643,"text":"关闭线程池，尝试停止正在执行的所有任务，不接受继续提交新任务"},"children":[]}]},{"data":{"id":"bsvkek5tc800","created":1553417100427,"text":"区别就是后者尝试停止正在执行的任务"},"children":[]}]},{"data":{"id":"bsvknm3aavk0","created":1553417809905,"text":"boolean isShutdown()判断是否关闭线程池"},"children":[]},{"data":{"id":"bsvkqd99p280","created":1553418025768,"text":"isTerminated判断任务是否终止","note":"该方法必须在调用shutdown或shutdownNow方法之后调用才会返回true\n"},"children":[]},{"data":{"id":"bsvkt6oobyo0","created":1553418246555,"text":"awaitTermination(long timeout)等待任务是否完成，并设置超时时间","note":"先调用 shutdown 或 shutdownNow， 然后再调这个方法等待所有的线程真正地完成，返回值意味着有没有超时\n```\nboolean awaitTermination(long timeout, TimeUnit unit)  throws InterruptedException;\n```\n"},"children":[]},{"data":{"id":"bsvkuzvm7fk0","created":1553418388465,"text":"submit"},"children":[{"data":{"id":"bsvkv3g51gw0","created":1553418396236,"text":"提交Runnable、Callable任务"},"children":[]}]},{"data":{"id":"bsvkwgnxhpc0","created":1553418503370,"text":"invokeAny、invokeAll"},"children":[]}]}]},{"data":{"id":"bsvjx789kvs0","created":1553415740086,"text":"ThreadPoolExecutor类"},"children":[]},{"data":{"id":"bsvk2kojcts0","created":1553416161189,"text":"Executors工具类","hyperlink":"https://blog.csdn.net/u010142437/article/details/22759163","hyperlinkTitle":""},"children":[]}]},{"data":{"id":"bsvjxsjbe3s0","created":1553415786466,"text":"Future接口"},"children":[{"data":{"id":"bsvjz2pq4ko0","created":1553415886986,"text":"RunnableFuture接口","note":"Future接口+Runnable接口"},"children":[{"data":{"id":"bsvjza4izu00","created":1553415903119,"text":"FutureTask类","resource":["实现RunnableFuture"],"note":"用于异步获取执行结果或取消执行任务的场景"},"children":[]}]}]},{"data":{"id":"bsvphpidmlk0","created":1553431452712,"text":"BlockingQueue接口"},"children":[{"data":{"id":"bsvphym38wg0","created":1553431472528,"text":"FIFO队列：LinkedBlockingQueue、ArrayBlockingQueue（固定长度）"},"children":[]},{"data":{"id":"bsvpi7lo8ao0","created":1553431492094,"text":"优先级队列 ：PriorityBlockingQueue"},"children":[]}]},{"data":{"id":"bsvk3wj7cdc0","created":1553416265352,"text":"ThreadFactory接口","note":"线程工厂，只定义了一个方法\n`Thread newThread(Runnable r);`创建线程"},"children":[]},{"data":{"id":"bsvlf2zrxhc0","created":1553419962530,"text":"Lock接口","note":"lock、unlock、tryLock([timeout])方法"},"children":[{"data":{"id":"bsvlfbkwj0o0","created":1553419981222,"text":"ReentrantLock类"},"children":[]}]},{"data":{"id":"bsvorsuk65c0","created":1553429422511,"text":"AQS（队列同步器）","note":"> AbstractQueuedSynchronizer\n\njava.util.concurrent.locks.AbstractQueuedSynchronizer\n\n> 构建锁或者其他同步组件的基础框架（如ReentrantLock、ReentrantReadWriteLock、Semaphore等），是JUC并发包中的核心基础组件","hyperlink":"https://juejin.im/entry/5ae02a7c6fb9a07ac76e7b70","hyperlinkTitle":""},"children":[{"data":{"id":"bsvp2bcwf6o0","created":1553430246444,"text":"CountDownLatch","note":"- 维护一个计数器cnt\n- countDown()会让计数器减一\n- cnt减到0时，调用await()方法等待的线程会被唤醒"},"children":[]},{"data":{"id":"bsvp3nfhg9k0","created":1553430351085,"text":"CyclicBarrier","note":"用来控制线程间相互等待，和 CountdownLatch 相似也是维护一个计数器cnt，不过是每个线程调用await方法后，计数器减一，直到cnt为0，所有调用 await() 方法而在等待的线程才能继续执行\n\nCyclicBarrier 的计数器通过调用 reset() 方法可以循环使用，所以它才叫做循环屏障"},"children":[]},{"data":{"id":"bsvpd1nhxmg0","created":1553431087322,"text":"Semaphore"},"children":[]}]}]},{"data":{"id":"bsvpu0qqf2o0","created":1553432417532,"text":"Java 内存模型","expandState":"collapse"},"children":[{"data":{"id":"bsvpv5zb5jk0","created":1553432507299,"text":"主内存和工作内存"},"children":[{"data":{"id":"bsvpvh8n7y00","created":1553432531808,"text":"所有变量存储在主内存中"},"children":[]},{"data":{"id":"bsvpvnbj1p40","created":1553432545043,"text":"工作内存存储了线程使用的变量的主内存副本拷贝"},"children":[]}]},{"data":{"id":"bsvpuqaw6ko0","created":1553432473171,"text":"线程只能直接操作工作内存中的变量，不同线程之间的变量值传递需要通过主内存来完成"},"children":[]},{"data":{"id":"bsvpydxr72w0","created":1553432759711,"text":"主内存和工作内存交互"},"children":[{"data":{"id":"bsvpykwah6g0","created":1553432774860,"text":"八大操作","image":"https://i.loli.net/2019/03/24/5c97808c648df.jpeg","imageTitle":"","imageSize":{"width":200,"height":75}},"children":[{"data":{"id":"bsvq3yzzhvs0","created":1553433197380,"text":"只保证单个操作具有原子性，合起来一起\n对变量而言就不具有原子性，所谓非同步"},"children":[]},{"data":{"id":"bsvq71js6600","created":1553433438023,"text":"使用原子类或者锁可以保证同步"},"children":[]}]},{"data":{"id":"bsvq90rdlu00","created":1553433593033,"text":"三大特性"},"children":[{"data":{"id":"bsvq92yua5s0","created":1553433597838,"text":"原子性"},"children":[]},{"data":{"id":"bsvq94ftg5c0","created":1553433601042,"text":"可见性","note":"可见性指当一个线程修改了共享变量的值，其它线程能够立即得知这个修改\n\nJava 内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值来实现可见性的"},"children":[{"data":{"id":"bsvqbzwalvc0","created":1553433826247,"text":"通过volatile、synchronized实现","note":"> volatile并非保证线程安全，任然是非原子性操作"},"children":[]},{"data":{"id":"bsvqca6h1540","created":1553433848630,"text":"定义为final变量"},"children":[]}]},{"data":{"id":"bsvq966x61s0","created":1553433604857,"text":"有序性","note":"有序性：在本线程内观察，所有操作都是有序的。\n在一个线程观察另一个线程，所有操作都是无序的，无序是因为发生了*指令重排序*。在 Java 内存模型中，允许编译器和处理器对指令进行重排序，*重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性*\t"},"children":[{"data":{"id":"bsvqmfyj5co0","created":1553434644852,"text":"volatile","note":"添加内存屏障的方式来禁止指令重排，即重排序时不能把后面的指令放到内存屏障之前"},"children":[]},{"data":{"id":"bsvqmhros0g0","created":1553434648792,"text":"synchronized","note":"synchronized 来保证有序性，它保证每个时刻只有一个线程执行同步代码，相当于是让线程顺序执行同步代码"},"children":[]}]}]}]}]},{"data":{"id":"bsvqsi617540","created":1553435119844,"text":"阻塞同步和非阻塞同步"},"children":[{"data":{"id":"bsvqsp6glo00","created":1553435135107,"text":"互斥同步（阻塞）"},"children":[{"data":{"id":"bsvquoqz9w80","created":1553435290900,"text":"synchronized、ReentrantLock"},"children":[]},{"data":{"id":"bsvqvdibqgw0","created":1553435344796,"text":"线程阻塞、唤醒性能消耗大","note":"加锁、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要唤醒等"},"children":[]}]},{"data":{"id":"bsvqssxy45k0","created":1553435143301,"text":"非阻塞同步"},"children":[{"data":{"id":"bsvqsvwx3go0","created":1553435149768,"text":"CAS算法"},"children":[{"data":{"id":"bsvqwf7d0s00","created":1553435426851,"text":"涉及ABA问题"},"children":[]}]},{"data":{"id":"bsvqt0h9w400","created":1553435159706,"text":"版本号机制"},"children":[]}]}]}]},"template":"default","theme":"fresh-blue","version":"1.4.43"}