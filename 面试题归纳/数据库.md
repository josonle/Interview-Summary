### 什么是 脏读、不可重复读、幻读
1、脏读(DirtyReads)：所谓脏读就是对脏数据（Drity Data）的读取，而脏数据所指的就是未提交的数据。一个事务正在对一条记录做修改，在这个事务完成并提交之前，这条数据是处于待定状态的（可能提交也可能回滚），这时，第二个事务来读取这条没有提交的数据，并据此做进一步的处理，就会产生未提交的数据依赖关系。

2、不可重复读(Non-RepeatableReads)：一个事务先后读取同一条记录，期间另一个事务修改了数据，并且已经commit，所以两次读取的数据不同，称之为不可重复读。

3、幻读(PhantomReads)：一个事务先后读取同一个表，期间其他事务插入了新的数据，并且已经commit，这种现象就称为幻读。
它和不可重复读的区别：不可重复读的重点是修改，幻读重点是新增和修改。

[来源：掘金](https://juejin.im/post/5b2a006c51882574b55e562e)

### 隔离级别

隔离性就是用来解决上述脏读、不可重复读、幻读

| 隔离级别        | 脏读 | 不可重复读 | 幻读 | 加锁读 |
| --------------- | :--: | ---------- | ---- | ------ |
| READ UNCOMMITED | Y | Y | Y | N |
| READ COMMITED   | N | Y | Y | N |
| REPEATABLE READ | N | N | Y | N |
| SERILIZABLE     | N | N | N | Y |

> EAD UNCOMMITTED级别最低，SERIALIZABLE级别最高。 级别越高肯定对于维护事务的四个特性就越好，但是它牺牲的是数据库的效率，因为SERIALIZABLE的实现是类似于java中的线程锁
>
> 
>
> MYSQL默认的是 REPEATABLE READ,事务默认自动提交，若想开启事务，使用set autocommit 命令



## 索引

### B+索引和Hash索引区别？

1. hash索引只适合等值比较，=、!=、in这些。不能用于范围查询，因为有序的键值经过哈希后也没序了
2. 如果键值唯一的话，等值比较hash索引有绝对优势
3. hash索引不支持多列联合索引的最左匹配规则
4. B+树索引检索效率较平均，B树波动幅度大，hash索引在大量重复键值存在的适合因为hash碰撞的缘故效率极低

### 为什么B+树适合作为索引结构而不是B树？

底层：B树是**有序数组+平衡多叉树**，B+树是**有序数组链表+平衡多叉树**

B+树叶子存储数据，空间占用低，而且链表是双向链表，修改效率快

B树适合随机检索，B+树同时支持随机和顺序检索



数据库索引采用B+树的主要原因是B树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题。
正是为了解决这个问题，B+树应运而生。B+树只要遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作（或者说效率太低）

### 索引使用注意项

- 对于联合索引，使用是遵循最左前缀原则，否则索引失效

  > 由于最左前缀原则，在创建联合索引时，索引字段的顺序需要考虑字段值去重之后的个数，较多的放前面。ORDERBY子句也遵循此规则

- 要避免冗杂索引，没意义

### 索引分类及创建

1. 主键索引，添加primary key：`alter table User add primary key('id');`
2. 唯一索引，添加unique：`alter table User add unique('column');`
3. 普通索引，添加index：`alter table table_name add index index_name('column');`
4. 全文索引，添加fulltext：`alter table table_name add fulltext('column');`
5. 多列索引：`alter table table_name add index index_name('c1','c2'...);`