# README

## 聊聊数据库中 count(1)、count(*)、count(col)区别

`count(col)`：这里col是指列，用来对特定的列统计行锁，排除null值
`count(*)`和`count(1)`：都用了统计表的总行锁，不忽略null

`count(*)`和`count(1)`的执行计划是一样的，我看有的博客上说`count(1)`时间略少，因为sql会对`count(*)`自动优化指定某个字段最后转成了`count(1)`，但差别很小。但我之前看《深入浅出MySQL》时记得MyISAM引擎会存储一个元数据信息，其中就包含`count(*)`，那明显**全表统计行数**时`count(*)`直接读取就行了（InnoDB中也会有一个表行数的变量，但只是估计值）。如果不是全表统计行数，还是会像上面说的一样优化。
但对于InnoDB引擎，MySQL5.5之后版本，二者没有区别也没有谁快之说。如果该表只有一个主键索引，没有任何二级索引的情况下，那么`count(*)`和`count(1)`都是通过通过主键索引来统计行数的。如果该表有二级索引，则`count(*)`和`count(1)`都会通过占用空间最小的字段的二级索引进行统计


> 参见：<https://zhuanlan.zhihu.com/p/28397595>
> 统计行数的操作,查询优化器的优化方向就是选择能够让IO次数最少的索引，也就是基于占用空间最小的字段所建的索引（每次IO读取的数据量是固定的，索引占用的空间越小所需的IO次数也就越少）。而Innodb的主键索引是聚簇索引（包含了KEY，除了KEY之外的其他字段值，事务ID和MVCC回滚指针）所以主键索引一定会比二级索引（包含KEY和对应的主键ID）大，也就是说在有二级索引的情况下，一般COUNT()都不会通过主键索引来统计行数，在有多个二级索引的情况下选择占用空间最小的。
> 如果说有张Innodb的表只有主键索引，而且记录还比较大（比如30K），则统计行的操作会非常慢，因为IO次数会很多（这里就不做实验截图了，有兴趣可以自己试一下）。一个优化方案就是预先建一个小字段并建二级索引专门用来统计行数，极端情况下这种优化速度提高上千倍也是正常的。

像InnoDB引擎中聚集索引一定存在，所以`count(*)`和`count(1)`都会走索引，所以如果col是主键的话，count(col)的效率高一点，毕竟`count(*)/count(1)`都会先转为count(主键)；如果col不是是主键的话，`count(*)/count(1)`更快

官方标准统计行数是使用count (*)

而且mysql 5.7版本又对InnoDB引擎下的count(*)优化了，参考：<https://yq.aliyun.com/articles/177835>